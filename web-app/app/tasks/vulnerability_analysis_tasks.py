"""Celery tasks for enhanced vulnerability analysis"""

import logging
import os
from datetime import datetime, timezone
from typing import Optional, List, Dict
from sqlalchemy.orm import Session
from ..celery_app import celery_app
from ..models.base import get_db
from ..models.scan import Scan
from ..models.vulnerability import Vulnerability
from ..config import settings
from ..services.enhanced_vulnerability_service import EnhancedVulnerabilityChecker

logger = logging.getLogger(__name__)


@celery_app.task(bind=True)
def enhanced_vulnerability_analysis(self, scan_id: int, vuls_json_path: str):
    """
    Run enhanced vulnerability analysis using OVAL and GOST databases
    and store results in database
    """
    start_time = datetime.now(timezone.utc)

    try:
        db = next(get_db())

        # Get scan record
        scan = db.query(Scan).filter(Scan.id == scan_id).first()
        if not scan:
            logger.error(f"Scan {scan_id} not found")
            return {"status": "error", "error": "Scan not found"}

        # Mark analysis as started
        scan.enhanced_analysis_started_at = start_time
        db.commit()

        logger.info(f"Starting enhanced vulnerability analysis for scan {scan_id}")

        # Initialize enhanced checker with database paths
        checker = EnhancedVulnerabilityChecker(
            oval_db_path="/app/db/oval.sqlite3",
            gost_db_path="/app/db/gost.sqlite3",
            cve_db_path="/app/db/cve.sqlite3"
        )

        # Run enhanced analysis
        packages = checker.get_installed_packages(vuls_json_path)
        logger.info(f"Found {len(packages)} packages to analyze")

        vulnerabilities = checker.check_enhanced_vulnerabilities(packages)
        logger.info(f"Found {len(vulnerabilities)} enhanced vulnerabilities")

        report_data = checker.generate_enhanced_report(vulnerabilities)

        # Store enhanced vulnerabilities in database
        store_enhanced_vulnerabilities(db, scan_id, vulnerabilities)

        # Store analysis summary
        store_vulnerability_analysis(db, scan_id, report_data, start_time)

        # Mark scan as enhanced analysis completed
        scan.enhanced_analysis_completed = True
        scan.enhanced_analysis_completed_at = datetime.now(timezone.utc)
        db.commit()

        # Send WebSocket notification
        try:
            from ..utils.notification_service import publish_task_notification
            publish_task_notification(
                task_id=0,  # No specific task ID for this
                task_run_id=0,  # No specific run ID
                status="enhanced_analysis_complete",
                task_name=f"Enhanced Analysis - {scan.host.name}",
                result_data={
                    "scan_id": scan_id,
                    "host_id": scan.host_id,
                    "total_vulnerabilities": report_data["total_vulnerabilities"],
                    "severity_breakdown": report_data["vulnerability_breakdown"],
                    "source_breakdown": report_data["source_breakdown"],
                    "packages_affected": report_data["packages_affected"]
                }
            )
        except Exception as e:
            logger.warning(f"Failed to send WebSocket notification: {e}")

        logger.info(f"Enhanced analysis completed for scan {scan_id}")

        return {
            "status": "success",
            "scan_id": scan_id,
            "vulnerabilities_found": len(vulnerabilities),
            "packages_analyzed": len(packages),
            "analysis_duration": (datetime.now(timezone.utc) - start_time).total_seconds()
        }

    except Exception as e:
        logger.error(f"Enhanced analysis failed for scan {scan_id}: {e}")

        # Mark analysis as failed but keep basic results
        try:
            db = next(get_db())
            scan = db.query(Scan).filter(Scan.id == scan_id).first()
            if scan:
                scan.enhanced_analysis_completed = False
                scan.enhanced_analysis_completed_at = datetime.now(timezone.utc)
                db.commit()
        except Exception as db_error:
            logger.error(f"Failed to update scan status after error: {db_error}")

        return {"status": "error", "error": str(e)}

    finally:
        try:
            db.close()
        except:
            pass


def store_enhanced_vulnerabilities(db: Session, scan_id: int, vulnerabilities: List[Dict]):
    """Store enhanced vulnerability data in database"""

    logger.info(f"Storing {len(vulnerabilities)} enhanced vulnerabilities for scan {scan_id}")

    for vuln_data in vulnerabilities:
        try:
            # Parse published date
            published_date = None
            if vuln_data.get("published_date"):
                try:
                    if isinstance(vuln_data["published_date"], str):
                        # Handle various date formats
                        date_str = vuln_data["published_date"]
                        if 'T' in date_str:
                            # ISO format
                            published_date = datetime.fromisoformat(date_str.replace('Z', '+00:00'))
                        else:
                            # Simple date format
                            published_date = datetime.strptime(date_str, '%Y-%m-%d').replace(tzinfo=timezone.utc)
                except Exception as date_error:
                    logger.warning(f"Failed to parse date {vuln_data['published_date']}: {date_error}")

            vulnerability = Vulnerability(
                scan_id=scan_id,
                cve_id=vuln_data["cve_id"],
                source=vuln_data.get("source", "ENHANCED"),
                affected_package=vuln_data["affected_package"],
                installed_version=vuln_data["installed_version"],
                fixed_version=vuln_data.get("fixed_version"),
                severity=vuln_data.get("severity", "unknown"),
                cvss_score=vuln_data.get("cvss_score", 0.0),
                priority=vuln_data.get("priority"),
                title=vuln_data.get("title"),
                description=vuln_data.get("description"),
                summary=vuln_data.get("summary"),
                published_date=published_date,
                definition_id=vuln_data.get("definition_id")
            )
            db.add(vulnerability)

        except Exception as e:
            logger.error(f"Failed to create vulnerability record for {vuln_data.get('cve_id', 'unknown')}: {e}")
            continue

    try:
        db.commit()
        logger.info(f"Successfully stored enhanced vulnerabilities for scan {scan_id}")
    except Exception as e:
        logger.error(f"Failed to commit vulnerabilities for scan {scan_id}: {e}")
        db.rollback()
        raise


def store_vulnerability_analysis(db: Session, scan_id: int, report_data: Dict, start_time: datetime):
    """Store vulnerability analysis summary"""

    try:
        from ..models.vulnerability import VulnerabilityAnalysis

        end_time = datetime.now(timezone.utc)
        duration = (end_time - start_time).total_seconds()

        # Check if analysis record already exists
        existing_analysis = db.query(VulnerabilityAnalysis).filter(
            VulnerabilityAnalysis.scan_id == scan_id
        ).first()

        if existing_analysis:
            # Update existing record
            existing_analysis.total_vulnerabilities = report_data["total_vulnerabilities"]
            existing_analysis.packages_analyzed = report_data["packages_affected"]
            existing_analysis.source_breakdown = report_data.get("source_breakdown", {})
            existing_analysis.severity_breakdown = report_data["vulnerability_breakdown"]
            existing_analysis.high_risk_packages = report_data["high_risk_packages"]
            existing_analysis.analysis_completed_at = end_time
            existing_analysis.analysis_duration_seconds = int(duration)
        else:
            # Create new record
            analysis = VulnerabilityAnalysis(
                scan_id=scan_id,
                total_vulnerabilities=report_data["total_vulnerabilities"],
                packages_analyzed=report_data["packages_affected"],
                source_breakdown=report_data.get("source_breakdown", {}),
                severity_breakdown=report_data["vulnerability_breakdown"],
                high_risk_packages=report_data["high_risk_packages"],
                analysis_completed_at=end_time,
                analysis_duration_seconds=int(duration)
            )
            db.add(analysis)

        db.commit()
        logger.info(f"Stored vulnerability analysis summary for scan {scan_id}")

    except Exception as e:
        logger.error(f"Failed to store vulnerability analysis for scan {scan_id}: {e}")
        db.rollback()
        raise

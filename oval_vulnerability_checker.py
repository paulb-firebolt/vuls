#!/usr/bin/env python3

import sqlite3
import json
import re
import logging
from typing import Dict, List, Optional, Tuple
from pathlib import Path

logger = logging.getLogger(__name__)


class OVALVulnerabilityChecker:
    """Direct OVAL vulnerability checker for Debian systems."""

    def __init__(self, oval_db_path: str, cve_db_path: str):
        self.oval_db_path = oval_db_path
        self.cve_db_path = cve_db_path

    def get_installed_packages(self, vuls_result_file: str) -> Dict[str, str]:
        """Extract installed packages from Vuls scan result."""
        try:
            with open(vuls_result_file, "r") as f:
                data = json.load(f)

            packages = {}
            for pkg_name, pkg_info in data.get("packages", {}).items():
                version = pkg_info.get("version", "")
                packages[pkg_name] = version

            return packages

        except Exception as e:
            logger.error(f"Error reading Vuls result file: {e}")
            return {}

    def check_vulnerabilities(self, packages: Dict[str, str]) -> List[Dict]:
        """Check packages against OVAL database for vulnerabilities."""
        vulnerabilities = []

        try:
            with sqlite3.connect(self.oval_db_path) as conn:
                cursor = conn.cursor()

                for package_name, version in packages.items():
                    # Query OVAL for this package
                    vulns = self._query_package_vulnerabilities(
                        cursor, package_name, version
                    )
                    vulnerabilities.extend(vulns)

            return vulnerabilities

        except Exception as e:
            logger.error(f"Error checking vulnerabilities: {e}")
            return []

    def _query_package_vulnerabilities(
        self, cursor, package_name: str, version: str
    ) -> List[Dict]:
        """Query OVAL database for a specific package."""
        vulnerabilities = []

        try:
            # Query for definitions affecting this package
            query = """
            SELECT DISTINCT d.definition_id, d.title, d.description
            FROM definitions d 
            JOIN debians deb ON d.id = deb.definition_id 
            WHERE d.root_id = 3 
            AND (d.title LIKE ? OR d.description LIKE ?)
            ORDER BY d.definition_id
            """

            cursor.execute(query, (f"%{package_name}%", f"%{package_name}%"))

            for row in cursor.fetchall():
                definition_id, title, description = row

                # Extract CVE ID from title
                cve_match = re.search(r"CVE-\d{4}-\d{4,}", title)
                cve_id = cve_match.group(0) if cve_match else None

                if cve_id:
                    # Get additional CVE details if available
                    cve_details = self._get_cve_details(cve_id)

                    vulnerability = {
                        "cve_id": cve_id,
                        "definition_id": definition_id,
                        "title": title,
                        "description": description or "",
                        "affected_package": package_name,
                        "installed_version": version,
                        "cvss_score": cve_details.get("cvss_score"),
                        "severity": cve_details.get("severity"),
                        "summary": cve_details.get("summary"),
                    }

                    vulnerabilities.append(vulnerability)

        except Exception as e:
            logger.warning(f"Error querying package {package_name}: {e}")

        return vulnerabilities

    def _get_cve_details(self, cve_id: str) -> Dict:
        """Get CVE details from CVE database."""
        try:
            with sqlite3.connect(self.cve_db_path) as conn:
                cursor = conn.cursor()
                cursor.execute(
                    """
                    SELECT cvss_score, cvss_severity, summary 
                    FROM cves 
                    WHERE cve_id = ?
                """,
                    (cve_id,),
                )

                row = cursor.fetchone()
                if row:
                    return {"cvss_score": row[0], "severity": row[1], "summary": row[2]}
        except Exception as e:
            logger.debug(f"Could not get CVE details for {cve_id}: {e}")

        return {}

    def generate_report(self, vulnerabilities: List[Dict]) -> Dict:
        """Generate vulnerability report summary."""
        if not vulnerabilities:
            return {
                "total_vulnerabilities": 0,
                "severity_counts": {
                    "critical": 0,
                    "high": 0,
                    "medium": 0,
                    "low": 0,
                    "unknown": 0,
                },
                "affected_packages": [],
                "vulnerabilities": [],
            }

        severity_counts = {
            "critical": 0,
            "high": 0,
            "medium": 0,
            "low": 0,
            "unknown": 0,
        }
        affected_packages = set()

        for vuln in vulnerabilities:
            severity = (vuln.get("severity") or "unknown").lower()
            if severity in severity_counts:
                severity_counts[severity] += 1
            else:
                severity_counts["unknown"] += 1

            affected_packages.add(vuln["affected_package"])

        return {
            "total_vulnerabilities": len(vulnerabilities),
            "severity_counts": severity_counts,
            "affected_packages": sorted(list(affected_packages)),
            "vulnerabilities": vulnerabilities,
        }

    def integrate_with_lynis_report(
        self, lynis_report_data: Dict, vulnerabilities: List[Dict]
    ) -> Dict:
        """Integrate vulnerability findings with Lynis report data."""
        # Add vulnerability findings to Lynis report
        vuln_findings = []

        for vuln in vulnerabilities:
            finding = {
                "control_id": f"VULS-{vuln['cve_id']}",
                "type": "WARNING",
                "status": "FOUND",
                "details": f"CVE: {vuln['cve_id']} | Package: {vuln['affected_package']} | Version: {vuln['installed_version']} | {vuln.get('summary', vuln['title'])}",
            }
            vuln_findings.append(finding)

        # Add to existing findings
        lynis_report_data.setdefault("findings", []).extend(vuln_findings)

        # Update hardening index based on vulnerabilities
        if vulnerabilities:
            # Reduce hardening index based on severity
            severity_penalties = {"critical": 10, "high": 5, "medium": 2, "low": 1}
            penalty = 0

            for vuln in vulnerabilities:
                severity = (vuln.get("severity") or "low").lower()
                penalty += severity_penalties.get(severity, 1)

            current_index = lynis_report_data.get("hardening_index", 100)
            lynis_report_data["hardening_index"] = max(0, current_index - penalty)

        return lynis_report_data


def main():
    """CLI interface for OVAL vulnerability checking."""
    import argparse

    parser = argparse.ArgumentParser(description="OVAL vulnerability checker")
    parser.add_argument(
        "--vuls-result", required=True, help="Path to Vuls scan result JSON"
    )
    parser.add_argument(
        "--oval-db", default="/vuls/db/oval.sqlite3", help="Path to OVAL database"
    )
    parser.add_argument(
        "--cve-db", default="/vuls/db/cve.sqlite3", help="Path to CVE database"
    )
    parser.add_argument("--output", help="Output JSON file")

    args = parser.parse_args()

    # Initialize checker
    checker = OVALVulnerabilityChecker(args.oval_db, args.cve_db)

    # Get installed packages
    packages = checker.get_installed_packages(args.vuls_result)
    print(f"Found {len(packages)} installed packages")

    # Check vulnerabilities
    vulnerabilities = checker.check_vulnerabilities(packages)
    print(f"Found {len(vulnerabilities)} potential vulnerabilities")

    # Generate report
    report = checker.generate_report(vulnerabilities)

    if args.output:
        with open(args.output, "w") as f:
            json.dump(report, f, indent=2)
        print(f"Report saved to {args.output}")
    else:
        print(json.dumps(report, indent=2))


if __name__ == "__main__":
    main()

"""Service for generating HTML vulnerability reports from database data"""

import logging
from datetime import datetime
from typing import List
from fastapi.templating import Jinja2Templates
from ..models.scan import Scan
from ..models.vulnerability import Vulnerability

logger = logging.getLogger(__name__)

# Initialize templates
templates = Jinja2Templates(directory="app/templates")


class VulnerabilityReportService:
    """Generate HTML vulnerability reports from database data using templates"""

    def __init__(self):
        # Add custom filters to the template environment
        templates.env.filters['severity_color'] = self.severity_color
        templates.env.filters['severity_badge'] = self.severity_badge
        templates.env.filters['format_date'] = self.format_date
        templates.env.filters['cvss_color'] = self.cvss_color
        templates.env.filters['risk_level'] = self.risk_level

    def severity_color(self, severity):
        """Return CSS color class for severity level."""
        colors = {
            'CRITICAL': 'bg-red-100 text-red-800 border-red-200',
            'HIGH': 'bg-orange-100 text-orange-800 border-orange-200',
            'MEDIUM': 'bg-yellow-100 text-yellow-800 border-yellow-200',
            'LOW': 'bg-blue-100 text-blue-800 border-blue-200',
            'unknown': 'bg-gray-100 text-gray-800 border-gray-200'
        }
        return colors.get(severity.upper() if severity else 'unknown', colors['unknown'])

    def severity_badge(self, severity):
        """Return severity badge HTML."""
        color_class = self.severity_color(severity)
        return f'<span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium border {color_class}">{(severity or "unknown").upper()}</span>'

    def format_date(self, date_obj):
        """Format date object for display."""
        if not date_obj:
            return "Unknown"
        try:
            if isinstance(date_obj, datetime):
                return date_obj.strftime('%Y-%m-%d')
            else:
                return str(date_obj)
        except:
            return "Unknown"

    def cvss_color(self, score):
        """Return color class based on CVSS score."""
        if not score:
            return 'text-gray-600'
        if score >= 9.0:
            return 'text-red-600'
        elif score >= 7.0:
            return 'text-orange-600'
        elif score >= 4.0:
            return 'text-yellow-600'
        else:
            return 'text-blue-600'

    def risk_level(self, risk_score):
        """Convert numeric risk score to text level."""
        if not risk_score:
            return 'Unknown'
        if risk_score >= 50:
            return 'Critical'
        elif risk_score >= 30:
            return 'High'
        elif risk_score >= 15:
            return 'Medium'
        else:
            return 'Low'

    def generate_scan_report(self, scan: Scan, vulnerabilities: List[Vulnerability]) -> str:
        """Generate HTML report for a specific scan"""

        # Transform database data to template format
        report_data = self._prepare_report_data(scan, vulnerabilities)

        # Use separate template file
        template = templates.get_template("vulnerability_report.html")
        return template.render(**report_data)

    def _prepare_report_data(self, scan: Scan, vulnerabilities: List[Vulnerability]) -> dict:
        """Transform database data to template format"""

        # Calculate severity breakdown
        severity_breakdown = self._calculate_severity_breakdown(vulnerabilities)

        # Calculate package breakdown
        package_breakdown = self._calculate_package_breakdown(vulnerabilities)

        # Calculate source breakdown
        source_breakdown = self._calculate_source_breakdown(vulnerabilities)

        # Prepare chart data
        chart_data = {
            'severity_distribution': severity_breakdown,
            'source_distribution': source_breakdown,
            'package_risk': package_breakdown[:10]  # Top 10 packages
        }

        return {
            'title': f"Vulnerability Report - {scan.host.name}",
            'generated_at': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'scan': {
                'id': scan.id,
                'host_name': scan.host.name,
                'hostname': scan.host.hostname,
                'scan_type': scan.scan_type,
                'completed_at': scan.completed_at,
                'enhanced_analysis_completed': scan.enhanced_analysis_completed
            },
            'summary': {
                'total_vulnerabilities': len(vulnerabilities),
                'packages_affected': len(set(v.affected_package for v in vulnerabilities)),
                'critical_count': severity_breakdown.get('CRITICAL', 0),
                'high_count': severity_breakdown.get('HIGH', 0),
                'medium_count': severity_breakdown.get('MEDIUM', 0),
                'low_count': severity_breakdown.get('LOW', 0),
            },
            'vulnerabilities': [
                {
                    'cve_id': vuln.cve_id,
                    'source': vuln.source,
                    'affected_package': vuln.affected_package,
                    'installed_version': vuln.installed_version,
                    'fixed_version': vuln.fixed_version,
                    'severity': vuln.severity,
                    'cvss_score': vuln.cvss_score,
                    'priority': vuln.priority,
                    'title': vuln.title,
                    'description': vuln.description,
                    'summary': vuln.summary,
                    'published_date': vuln.published_date
                }
                for vuln in vulnerabilities
            ],
            'chart_data': chart_data,
            'severity_breakdown': severity_breakdown,
            'source_breakdown': source_breakdown,
            'package_breakdown': package_breakdown
        }

    def _calculate_severity_breakdown(self, vulnerabilities: List[Vulnerability]) -> dict:
        """Calculate severity distribution"""
        breakdown = {"CRITICAL": 0, "HIGH": 0, "MEDIUM": 0, "LOW": 0, "unknown": 0}
        for vuln in vulnerabilities:
            severity = (vuln.severity or "unknown").upper()
            if severity in breakdown:
                breakdown[severity] += 1
            else:
                breakdown["unknown"] += 1
        return breakdown

    def _calculate_source_breakdown(self, vulnerabilities: List[Vulnerability]) -> dict:
        """Calculate source distribution"""
        breakdown = {}
        for vuln in vulnerabilities:
            source = vuln.source or "unknown"
            breakdown[source] = breakdown.get(source, 0) + 1
        return breakdown

    def _calculate_package_breakdown(self, vulnerabilities: List[Vulnerability]) -> List[dict]:
        """Calculate per-package vulnerability counts"""
        packages = {}
        for vuln in vulnerabilities:
            pkg = vuln.affected_package
            if pkg not in packages:
                packages[pkg] = {"total": 0, "critical": 0, "high": 0, "medium": 0, "low": 0}

            packages[pkg]["total"] += 1
            severity = (vuln.severity or "unknown").lower()
            if severity in packages[pkg]:
                packages[pkg][severity] += 1

        # Calculate risk scores and sort
        package_list = []
        for pkg, counts in packages.items():
            risk_score = (
                counts["critical"] * 20
                + counts["high"] * 10
                + counts["medium"] * 5
                + counts["low"] * 1
            )
            package_list.append({
                "package": pkg,
                "total_vulns": counts["total"],
                "critical": counts["critical"],
                "high": counts["high"],
                "medium": counts["medium"],
                "low": counts["low"],
                "risk_score": risk_score
            })

        return sorted(package_list, key=lambda x: x["risk_score"], reverse=True)

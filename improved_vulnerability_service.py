#!/usr/bin/env python3
"""
Improved vulnerability checker service with better version comparison logic.
This addresses the false positive issues identified in the current implementation.
"""

import sqlite3
import json
import os
import re
import logging
from typing import Dict, List, Set, Optional, Tuple
from packaging import version
from pathlib import Path

logger = logging.getLogger(__name__)


class ImprovedVulnerabilityChecker:
    """Improved vulnerability checker with better Debian version handling."""

    def __init__(self, oval_db_path: str, gost_db_path: str, cve_db_path: str):
        self.oval_db_path = oval_db_path
        self.gost_db_path = gost_db_path
        self.cve_db_path = cve_db_path

    def parse_debian_version(self, version_str: str) -> Dict[str, str]:
        """
        Parse a Debian version string into its components.

        Format: [epoch:]upstream_version[-debian_revision][+build_info]
        Examples:
        - "7.88.1-10+deb12u12" -> {epoch: "", upstream: "7.88.1", debian: "10", build: "deb12u12"}
        - "1:7.88.1-10" -> {epoch: "1", upstream: "7.88.1", debian: "10", build: ""}
        - "7.88.1" -> {epoch: "", upstream: "7.88.1", debian: "", build: ""}
        """
        if not version_str:
            return {"epoch": "", "upstream": "0", "debian": "", "build": ""}

        # Handle epoch (1:version)
        epoch = ""
        remaining = version_str
        if ":" in version_str:
            epoch, remaining = version_str.split(":", 1)

        # Handle build info (+deb12u12)
        build = ""
        if "+" in remaining:
            remaining, build = remaining.split("+", 1)

        # Handle debian revision (-10)
        debian = ""
        if "-" in remaining:
            upstream, debian = remaining.rsplit("-", 1)
        else:
            upstream = remaining

        # Clean upstream version for pre-release handling
        upstream = self._clean_upstream_version(upstream)

        return {
            "epoch": epoch,
            "upstream": upstream,
            "debian": debian,
            "build": build
        }

    def _clean_upstream_version(self, version_str: str) -> str:
        """Clean upstream version for proper comparison."""
        if not version_str:
            return "0"

        # Handle pre-release versions with ~
        # 7.88.0~rc1 -> 7.88.0rc1
        cleaned = version_str.replace("~", "")

        # Handle git snapshots
        # 2.0.0~git20210101 -> 2.0.0.git20210101
        cleaned = re.sub(r"~git(\d+)", r".git\1", cleaned)

        # Remove any remaining invalid characters but keep rc, a, b for pre-releases
        cleaned = re.sub(r"[^0-9.rcab]", "", cleaned)

        # Ensure we have a valid version
        if not cleaned or cleaned == ".":
            return "0"

        return cleaned

    def compare_debian_versions(self, installed: str, fixed: str) -> int:
        """
        Compare two Debian version strings.
        Returns: -1 if installed < fixed (vulnerable)
                  0 if installed == fixed (equal)
                  1 if installed > fixed (safe)
        """
        try:
            inst_parts = self.parse_debian_version(installed)
            fixed_parts = self.parse_debian_version(fixed)

            # Compare epoch first
            inst_epoch = int(inst_parts["epoch"]) if inst_parts["epoch"] else 0
            fixed_epoch = int(fixed_parts["epoch"]) if fixed_parts["epoch"] else 0

            if inst_epoch != fixed_epoch:
                return -1 if inst_epoch < fixed_epoch else 1

            # Compare upstream versions
            try:
                inst_upstream = version.parse(inst_parts["upstream"])
                fixed_upstream = version.parse(fixed_parts["upstream"])

                if inst_upstream != fixed_upstream:
                    return -1 if inst_upstream < fixed_upstream else 1
            except Exception as e:
                logger.warning(f"Error comparing upstream versions: {e}")
                # Fall back to string comparison
                if inst_parts["upstream"] != fixed_parts["upstream"]:
                    return -1 if inst_parts["upstream"] < fixed_parts["upstream"] else 1

            # If upstream versions are equal, compare Debian revisions
            if inst_parts["debian"] and fixed_parts["debian"]:
                try:
                    inst_debian = int(inst_parts["debian"])
                    fixed_debian = int(fixed_parts["debian"])

                    if inst_debian != fixed_debian:
                        return -1 if inst_debian < fixed_debian else 1
                except ValueError:
                    # Non-numeric debian revisions, use string comparison
                    if inst_parts["debian"] != fixed_parts["debian"]:
                        return -1 if inst_parts["debian"] < fixed_parts["debian"] else 1

            # If Debian revisions are equal, compare build info (security updates)
            if inst_parts["build"] and fixed_parts["build"]:
                # Extract security update numbers (e.g., deb12u12 -> 12)
                inst_security = self._extract_security_update_number(inst_parts["build"])
                fixed_security = self._extract_security_update_number(fixed_parts["build"])

                if inst_security is not None and fixed_security is not None:
                    if inst_security != fixed_security:
                        return -1 if inst_security < fixed_security else 1

            return 0  # Versions are equal

        except Exception as e:
            logger.warning(f"Error comparing Debian versions {installed} vs {fixed}: {e}")
            # Default to vulnerable if we can't compare
            return -1

    def _extract_security_update_number(self, build_info: str) -> Optional[int]:
        """Extract security update number from build info (e.g., deb12u12 -> 12)."""
        match = re.search(r"deb\d+u(\d+)", build_info)
        if match:
            return int(match.group(1))
        return None

    def is_version_vulnerable_improved(self, installed_version: str, fixed_version: str) -> bool:
        """
        Improved version vulnerability check with proper Debian version handling.
        Returns True if installed version is vulnerable, False if safe.
        """
        try:
            comparison = self.compare_debian_versions(installed_version, fixed_version)

            # Log the comparison for debugging
            logger.debug(f"Version comparison: {installed_version} vs {fixed_version} = {comparison}")

            # If installed < fixed, it's vulnerable
            return comparison < 0

        except Exception as e:
            logger.warning(f"Error in improved version comparison {installed_version} vs {fixed_version}: {e}")
            # Default to vulnerable if we can't compare
            return True

    def check_debian_security_tracker(self, package_name: str, cve_id: str) -> Optional[Dict]:
        """
        Check if a CVE has been addressed in Debian security tracker.
        This helps reduce false positives from backported fixes.
        """
        # This would ideally query the Debian Security Tracker API
        # For now, we'll implement a basic check

        # Known packages that frequently have backported security fixes
        backport_packages = {
            "curl", "openssl", "openssh-server", "openssh-client",
            "nginx", "apache2", "php", "python3", "nodejs"
        }

        if package_name in backport_packages:
            logger.info(f"Package {package_name} commonly has backported fixes for {cve_id}")
            # Could return additional context about backports
            return {"has_backports": True, "package": package_name, "cve": cve_id}

        return None

    def validate_vulnerability_match(self, vulnerability: Dict) -> bool:
        """
        Validate if a vulnerability match is likely to be accurate.
        This helps filter out false positives.
        """
        package_name = vulnerability.get("affected_package", "")
        cve_id = vulnerability.get("cve_id", "")
        installed_version = vulnerability.get("installed_version", "")
        fixed_version = vulnerability.get("fixed_version", "")

        # Skip if essential information is missing
        if not all([package_name, cve_id, installed_version]):
            return False

        # Check for common false positive patterns
        false_positive_indicators = [
            # CVE title doesn't really match the package
            lambda v: package_name.lower() not in v.get("title", "").lower(),

            # Very old CVEs that are likely already patched
            lambda v: self._is_very_old_cve(cve_id),

            # Version comparison seems suspicious
            lambda v: not fixed_version or fixed_version == "unknown",
        ]

        for indicator in false_positive_indicators:
            if indicator(vulnerability):
                logger.debug(f"Potential false positive detected for {package_name} {cve_id}")
                return False

        return True

    def _is_very_old_cve(self, cve_id: str) -> bool:
        """Check if CVE is very old (likely already patched in modern systems)."""
        match = re.search(r"CVE-(\d{4})", cve_id)
        if match:
            year = int(match.group(1))
            # Consider CVEs older than 2020 as potentially stale
            return year < 2020
        return False

    def generate_vulnerability_confidence_score(self, vulnerability: Dict) -> float:
        """
        Generate a confidence score for a vulnerability match (0.0 to 1.0).
        Higher scores indicate more confidence in the match.
        """
        score = 0.5  # Base score

        package_name = vulnerability.get("affected_package", "")
        cve_id = vulnerability.get("cve_id", "")
        title = vulnerability.get("title", "").lower()
        installed_version = vulnerability.get("installed_version", "")
        fixed_version = vulnerability.get("fixed_version", "")

        # Increase confidence if package name is prominently mentioned in title
        if package_name.lower() in title:
            score += 0.2

        # Increase confidence if we have a proper fixed version
        if fixed_version and fixed_version != "unknown":
            score += 0.2

        # Increase confidence for recent CVEs
        match = re.search(r"CVE-(\d{4})", cve_id)
        if match:
            year = int(match.group(1))
            if year >= 2022:
                score += 0.1
            elif year >= 2020:
                score += 0.05

        # Decrease confidence for very complex version strings that might be misparsed
        if len(installed_version.split("-")) > 3:
            score -= 0.1

        # Increase confidence if CVSS score is available and significant
        cvss_score = vulnerability.get("cvss_score", 0)
        if cvss_score >= 7.0:
            score += 0.1
        elif cvss_score >= 4.0:
            score += 0.05

        return max(0.0, min(1.0, score))

    def enhanced_vulnerability_check(self, all_packages: Dict[str, str]) -> List[Dict]:
        """
        Enhanced vulnerability check with improved version comparison and validation.
        """
        # Use the existing package identification logic
        packages_to_scan = self.identify_vulnerable_packages(all_packages)

        logger.info(f"Scanning {len(packages_to_scan)} packages with improved logic...")

        vulnerabilities = []

        # Check OVAL database with improved logic
        oval_vulns = self._check_oval_vulnerabilities_improved(packages_to_scan, all_packages)
        vulnerabilities.extend(oval_vulns)

        # Check GOST database with improved logic
        gost_vulns = self._check_gost_vulnerabilities_improved(packages_to_scan, all_packages)
        vulnerabilities.extend(gost_vulns)

        # Filter and validate vulnerabilities
        validated_vulns = []
        for vuln in vulnerabilities:
            if self.validate_vulnerability_match(vuln):
                vuln["confidence_score"] = self.generate_vulnerability_confidence_score(vuln)
                validated_vulns.append(vuln)
            else:
                logger.debug(f"Filtered out potential false positive: {vuln.get('cve_id')} for {vuln.get('affected_package')}")

        # Deduplicate
        deduplicated = self._deduplicate_vulnerabilities(validated_vulns)

        logger.info(f"Found {len(deduplicated)} validated vulnerabilities (filtered from {len(vulnerabilities)} total)")

        return deduplicated

    def _check_oval_vulnerabilities_improved(self, packages_to_scan: Set[str], all_packages: Dict[str, str]) -> List[Dict]:
        """Check OVAL vulnerabilities with improved version comparison."""
        vulnerabilities = []

        try:
            with sqlite3.connect(self.oval_db_path) as conn:
                cursor = conn.cursor()

                for package_name in sorted(packages_to_scan):
                    if package_name in all_packages:
                        version = all_packages[package_name]
                        vulns = self._query_oval_package_improved(cursor, package_name, version)
                        vulnerabilities.extend(vulns)

        except Exception as e:
            logger.error(f"Error checking OVAL vulnerabilities: {e}")

        return vulnerabilities

    def _query_oval_package_improved(self, cursor, package_name: str, installed_version: str) -> List[Dict]:
        """Query OVAL database with improved version comparison."""
        vulnerabilities = []

        try:
            query = """
            SELECT DISTINCT d.definition_id, d.title, d.description, p.version as fixed_version
            FROM definitions d
            JOIN debians deb ON d.id = deb.definition_id
            JOIN packages p ON d.id = p.definition_id
            WHERE d.root_id = 3
            AND p.name = ?
            AND (d.title LIKE ? OR d.title LIKE ?)
            ORDER BY d.definition_id DESC
            """

            pattern1 = f"% {package_name} %"
            pattern2 = f"% {package_name}"

            cursor.execute(query, (package_name, pattern1, pattern2))

            for row in cursor.fetchall():
                definition_id, title, description, fixed_version = row

                # Extract CVE ID
                cve_match = re.search(r"CVE-\d{4}-\d{4,}", title)
                if not cve_match:
                    continue

                cve_id = cve_match.group(0)

                # Use improved version comparison
                if not self.is_version_vulnerable_improved(installed_version, fixed_version):
                    logger.debug(f"Skipping {cve_id} for {package_name}: version {installed_version} is not vulnerable (fixed in {fixed_version})")
                    continue

                # Get CVE details
                cve_details = self._get_cve_details(cve_id)

                vulnerability = {
                    "cve_id": cve_id,
                    "source": "OVAL",
                    "definition_id": definition_id,
                    "title": title,
                    "description": description or "",
                    "affected_package": package_name,
                    "installed_version": installed_version,
                    "fixed_version": fixed_version,
                    "cvss_score": cve_details.get("cvss_score", 0.0),
                    "severity": cve_details.get("severity", "unknown"),
                    "summary": cve_details.get("summary", ""),
                    "published_date": cve_details.get("published_date", ""),
                }

                vulnerabilities.append(vulnerability)

        except Exception as e:
            logger.warning(f"Error querying OVAL for package {package_name}: {e}")

        return vulnerabilities

    # Include the other methods from the original class
    def identify_vulnerable_packages(self, all_packages: Dict[str, str]) -> Set[str]:
        """Reuse the existing package identification logic."""
        # Copy the implementation from the original class
        critical_packages = {
            "openssl", "openssh-server", "openssh-client", "sudo", "systemd",
            "libc6", "libc-bin", "glibc", "bash", "curl", "wget", "git",
        }

        high_risk_patterns = [
            (r".*ssh.*", "SSH-related"),
            (r".*ssl.*", "SSL/TLS libraries"),
            (r".*curl.*", "HTTP clients"),
            # ... (include all patterns from original)
        ]

        vulnerable_packages = set(critical_packages)

        for pkg_name in all_packages.keys():
            for pattern, category in high_risk_patterns:
                if re.match(pattern, pkg_name, re.IGNORECASE):
                    vulnerable_packages.add(pkg_name)
                    break

        return {pkg for pkg in vulnerable_packages if pkg in all_packages}

    def _check_gost_vulnerabilities_improved(self, packages_to_scan: Set[str], all_packages: Dict[str, str]) -> List[Dict]:
        """Placeholder for improved GOST checking."""
        # Implementation would be similar to OVAL but for GOST database
        return []

    def _deduplicate_vulnerabilities(self, vulnerabilities: List[Dict]) -> List[Dict]:
        """Remove duplicate vulnerabilities."""
        seen = set()
        deduplicated = []

        for vuln in vulnerabilities:
            key = (vuln["cve_id"], vuln["affected_package"])
            if key not in seen:
                seen.add(key)
                deduplicated.append(vuln)

        return deduplicated

    def _get_cve_details(self, cve_id: str) -> Dict:
        """Get CVE details from database."""
        # Reuse implementation from original class
        return {}


def test_improved_version_comparison():
    """Test the improved version comparison logic."""
    checker = ImprovedVulnerabilityChecker("", "", "")

    test_cases = [
        # (installed, fixed, expected_vulnerable, description)
        ("7.88.1-10+deb12u12", "7.88.1-10+deb12u5", False, "Newer security patch installed"),
        ("7.88.1-10+deb12u5", "7.88.1-10+deb12u12", True, "Older security patch installed"),
        ("7.88.1-10+deb12u12", "7.89.0", True, "Major version difference"),
        ("7.89.0-1", "7.88.1-10+deb12u12", False, "Newer major version"),
        ("1:7.88.1-10", "7.89.0", False, "Epoch version handling"),
        ("7.88.0~rc1-1", "7.88.0", True, "Pre-release version"),
    ]

    print("=== Testing Improved Version Comparison ===\n")

    for installed, fixed, expected, description in test_cases:
        result = checker.is_version_vulnerable_improved(installed, fixed)
        status = "✓" if result == expected else "✗"

        print(f"{status} {description}")
        print(f"   Installed: {installed}")
        print(f"   Fixed:     {fixed}")
        print(f"   Expected:  {'Vulnerable' if expected else 'Safe'}")
        print(f"   Got:       {'Vulnerable' if result else 'Safe'}")

        if result != expected:
            print(f"   ⚠️  MISMATCH!")
        print()


if __name__ == "__main__":
    test_improved_version_comparison()

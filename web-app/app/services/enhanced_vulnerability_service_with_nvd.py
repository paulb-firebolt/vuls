"""
Enhanced Vulnerability Service with NVD Integration
Combines distribution sources with NVD for comprehensive vulnerability detection.
Designed to catch CVEs that may be missing from distribution OVAL data.
"""

import logging
from typing import Dict, List, Optional, Set
from datetime import datetime
from .enhanced_vulnerability_service_pg import EnhancedVulnerabilityCheckerPG
from .nvd_cve_source import NVDCVESource
from .unified_ubuntu_security import unified_ubuntu_security
from .unified_debian_security import unified_debian_security

logger = logging.getLogger(__name__)


class EnhancedVulnerabilityServiceWithNVD(EnhancedVulnerabilityCheckerPG):
    """Enhanced vulnerability service with NVD gap analysis."""

    def __init__(self):
        super().__init__()
        self.nvd_source = NVDCVESource()
        logger.info("Enhanced Vulnerability Service with NVD initialized")

    def analyze_package_vulnerabilities(self, package_name: str, installed_version: str,
                                      os_info: Dict, include_nvd_gap_analysis: bool = True) -> Dict:
        """
        Analyze package vulnerabilities with optional NVD gap analysis.

        Args:
            package_name: Name of the package
            installed_version: Currently installed version
            os_info: Operating system information
            include_nvd_gap_analysis: Whether to check NVD for missing CVEs

        Returns:
            Comprehensive vulnerability analysis including potential gaps
        """
        # Create a mock package dictionary for the existing method
        all_packages = {package_name: installed_version}

        # Get standard analysis using existing method
        vulnerabilities = self.check_enhanced_vulnerabilities(all_packages, os_info.get('os_family'))

        # Filter to only vulnerabilities for this specific package
        package_vulns = [v for v in vulnerabilities if v.get('affected_package') == package_name]

        # Create standard analysis structure
        standard_analysis = {
            'package_name': package_name,
            'installed_version': installed_version,
            'os_info': os_info,
            'vulnerabilities': package_vulns,
            'total_vulnerabilities': len(package_vulns),
            'summary': {
                'found_vulnerabilities': len(package_vulns),
                'high_severity': len([v for v in package_vulns if v.get('severity', '').upper() in ['HIGH', 'CRITICAL']]),
                'medium_severity': len([v for v in package_vulns if v.get('severity', '').upper() == 'MEDIUM']),
                'low_severity': len([v for v in package_vulns if v.get('severity', '').upper() == 'LOW'])
            }
        }

        if not include_nvd_gap_analysis:
            return standard_analysis

        # Perform NVD gap analysis
        try:
            gap_analysis = self._perform_nvd_gap_analysis(
                package_name, standard_analysis, os_info
            )

            # Merge gap analysis into standard results
            standard_analysis['nvd_gap_analysis'] = gap_analysis
            standard_analysis['total_vulnerabilities'] += len(gap_analysis.get('missing_cves', []))

            # Update summary
            if gap_analysis.get('missing_cves'):
                standard_analysis['summary']['potential_missing_cves'] = len(gap_analysis['missing_cves'])
                standard_analysis['summary']['requires_investigation'] = True

                # Highlight high-severity missing CVEs
                high_severity_missing = [
                    cve for cve in gap_analysis['missing_cves']
                    if cve.get('cvss_score', 0) >= 7.0
                ]
                if high_severity_missing:
                    standard_analysis['summary']['high_severity_missing'] = len(high_severity_missing)
                    standard_analysis['summary']['risk_level'] = 'High'

        except Exception as e:
            logger.error(f"Error performing NVD gap analysis for {package_name}: {e}")
            standard_analysis['nvd_gap_analysis'] = {
                'error': str(e),
                'status': 'failed'
            }

        return standard_analysis

    def _perform_nvd_gap_analysis(self, package_name: str, standard_analysis: Dict, os_info: Dict) -> Dict:
        """Perform NVD gap analysis to find potentially missing CVEs."""
        logger.info(f"Performing NVD gap analysis for {package_name}")

        # Extract known CVEs from standard analysis
        known_cves = set()
        for vuln in standard_analysis.get('vulnerabilities', []):
            cve_id = vuln.get('cve_id', '')
            if cve_id:
                known_cves.add(cve_id)

        # Search NVD for additional CVEs
        missing_cves = self.nvd_source.find_missing_cves(package_name, known_cves)

        # Filter and enhance missing CVEs
        filtered_missing = []
        for cve in missing_cves:
            # Apply additional filtering based on relevance and severity
            if self._should_include_missing_cve(cve, package_name, os_info):
                # Enhance with additional context
                enhanced_cve = self._enhance_missing_cve(cve, package_name, os_info)
                filtered_missing.append(enhanced_cve)

        # Sort by potential risk
        filtered_missing.sort(
            key=lambda x: (x.get('cvss_score', 0), x.get('relevance_score', 0)),
            reverse=True
        )

        gap_analysis = {
            'status': 'completed',
            'package_name': package_name,
            'search_time': datetime.now().isoformat(),
            'known_cves_count': len(known_cves),
            'nvd_total_found': len(missing_cves),
            'filtered_missing_count': len(filtered_missing),
            'missing_cves': filtered_missing[:20],  # Limit to top 20 for performance
            'summary': {
                'has_potential_gaps': len(filtered_missing) > 0,
                'high_severity_missing': len([c for c in filtered_missing if c.get('cvss_score', 0) >= 7.0]),
                'medium_severity_missing': len([c for c in filtered_missing if 4.0 <= c.get('cvss_score', 0) < 7.0]),
                'requires_manual_review': len(filtered_missing) > 0
            }
        }

        logger.info(f"NVD gap analysis for {package_name}: {len(filtered_missing)} potential missing CVEs")
        return gap_analysis

    def _should_include_missing_cve(self, cve: Dict, package_name: str, os_info: Dict) -> bool:
        """Determine if a missing CVE should be included in the gap analysis."""
        # Minimum relevance threshold
        if cve.get('relevance_score', 0) < 0.3:
            return False

        # Include high-severity CVEs even with lower relevance
        if cve.get('cvss_score', 0) >= 7.0:
            return True

        # Include medium-severity with good relevance
        if cve.get('cvss_score', 0) >= 4.0 and cve.get('relevance_score', 0) >= 0.5:
            return True

        # Include if very high relevance regardless of severity
        if cve.get('relevance_score', 0) >= 0.8:
            return True

        return False

    def _enhance_missing_cve(self, cve: Dict, package_name: str, os_info: Dict) -> Dict:
        """Enhance missing CVE with additional context and analysis."""
        enhanced = cve.copy()

        # Add investigation recommendations
        enhanced['investigation'] = {
            'priority': self._calculate_investigation_priority(cve),
            'recommended_actions': self._get_recommended_actions(cve, package_name, os_info),
            'potential_false_positive': self._assess_false_positive_risk(cve, package_name)
        }

        # Add distribution context
        enhanced['distribution_context'] = {
            'os_family': os_info.get('os_family', 'unknown'),
            'os_version': os_info.get('version', 'unknown'),
            'possible_reasons_for_absence': self._analyze_absence_reasons(cve, os_info)
        }

        return enhanced

    def _calculate_investigation_priority(self, cve: Dict) -> str:
        """Calculate investigation priority for a missing CVE."""
        cvss_score = cve.get('cvss_score', 0)
        relevance_score = cve.get('relevance_score', 0)

        if cvss_score >= 9.0:
            return 'Critical'
        elif cvss_score >= 7.0 and relevance_score >= 0.6:
            return 'High'
        elif cvss_score >= 4.0 and relevance_score >= 0.5:
            return 'Medium'
        else:
            return 'Low'

    def _get_recommended_actions(self, cve: Dict, package_name: str, os_info: Dict) -> List[str]:
        """Get recommended actions for investigating a missing CVE."""
        actions = []

        # Always recommend manual verification
        actions.append(f"Manually verify if {cve.get('cve_id')} affects the installed version of {package_name}")

        # Check distribution security advisories
        if os_info.get('os_family') == 'ubuntu':
            actions.append("Check Ubuntu Security Notices (USN) for this CVE")
        elif os_info.get('os_family') == 'debian':
            actions.append("Check Debian Security Advisories (DSA) for this CVE")

        # High-severity specific actions
        if cve.get('cvss_score', 0) >= 7.0:
            actions.append("Consider immediate patching or mitigation due to high severity")
            actions.append("Review system logs for potential exploitation attempts")

        # Check upstream sources
        actions.append(f"Check {package_name} upstream security advisories")

        return actions

    def _assess_false_positive_risk(self, cve: Dict, package_name: str) -> str:
        """Assess the risk that this is a false positive."""
        relevance_score = cve.get('relevance_score', 0)

        if relevance_score >= 0.8:
            return 'Low'
        elif relevance_score >= 0.5:
            return 'Medium'
        else:
            return 'High'

    def _analyze_absence_reasons(self, cve: Dict, os_info: Dict) -> List[str]:
        """Analyze possible reasons why a CVE might be absent from distribution sources."""
        reasons = []

        # Check publication date
        published = cve.get('published', '')
        if published:
            try:
                pub_date = datetime.fromisoformat(published.replace('Z', '+00:00'))
                days_old = (datetime.now(pub_date.tzinfo) - pub_date).days

                if days_old < 7:
                    reasons.append("Recently published CVE - may not yet be in distribution trackers")
                elif days_old < 30:
                    reasons.append("Relatively new CVE - distribution may still be evaluating")
            except:
                pass

        # Check severity
        cvss_score = cve.get('cvss_score', 0)
        if cvss_score < 4.0:
            reasons.append("Low severity - distribution may have deprioritized")

        # Check if it might be version-specific
        if cve.get('relevance_score', 0) < 0.6:
            reasons.append("May affect different version ranges than those in distribution")

        # Distribution-specific reasons
        os_family = os_info.get('os_family', '').lower()
        if os_family in ['ubuntu', 'debian']:
            reasons.append("Distribution may have determined it doesn't affect their package builds")
            reasons.append("May be fixed by distribution-specific patches not reflected in version numbers")

        return reasons

    def generate_comprehensive_report(self, scan_results: List[Dict],
                                    include_nvd_analysis: bool = True) -> Dict:
        """Generate comprehensive vulnerability report including NVD gap analysis."""
        # Get standard report
        standard_report = super().generate_comprehensive_report(scan_results)

        if not include_nvd_analysis:
            return standard_report

        # Add NVD-specific sections
        nvd_summary = {
            'total_packages_analyzed': 0,
            'packages_with_potential_gaps': 0,
            'total_potential_missing_cves': 0,
            'high_severity_missing': 0,
            'requires_investigation': []
        }

        for result in scan_results:
            nvd_analysis = result.get('nvd_gap_analysis', {})
            if nvd_analysis.get('status') == 'completed':
                nvd_summary['total_packages_analyzed'] += 1

                missing_cves = nvd_analysis.get('missing_cves', [])
                if missing_cves:
                    nvd_summary['packages_with_potential_gaps'] += 1
                    nvd_summary['total_potential_missing_cves'] += len(missing_cves)

                    high_severity = [c for c in missing_cves if c.get('cvss_score', 0) >= 7.0]
                    nvd_summary['high_severity_missing'] += len(high_severity)

                    if high_severity:
                        nvd_summary['requires_investigation'].append({
                            'package': result.get('package_name'),
                            'high_severity_count': len(high_severity),
                            'top_cve': high_severity[0].get('cve_id') if high_severity else None
                        })

        # Add to standard report
        standard_report['nvd_gap_analysis'] = nvd_summary

        # Update overall risk assessment
        if nvd_summary['high_severity_missing'] > 0:
            standard_report['overall_risk_level'] = 'Critical - Potential Missing High-Severity CVEs'
        elif nvd_summary['total_potential_missing_cves'] > 0:
            current_risk = standard_report.get('overall_risk_level', 'Low')
            if current_risk == 'Low':
                standard_report['overall_risk_level'] = 'Medium - Potential Missing CVEs Detected'

        return standard_report

    def get_nvd_statistics(self) -> Dict:
        """Get NVD source statistics."""
        return self.nvd_source.get_cache_stats()


# Global instance with NVD integration
enhanced_vulnerability_service_with_nvd = EnhancedVulnerabilityServiceWithNVD()

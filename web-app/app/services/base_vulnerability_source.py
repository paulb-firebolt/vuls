"""
Base classes for vulnerability data sources.
Provides a flexible architecture for different vulnerability databases.
"""

from abc import ABC, abstractmethod
from typing import Dict, List, Optional, Any
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BaseVulnerabilitySource(ABC):
    """Abstract base class for vulnerability data sources."""

    def __init__(self, source_name: str, source_type: str):
        self.source_name = source_name
        self.source_type = source_type
        self.logger = logging.getLogger(f"{__name__}.{source_name}")

    @abstractmethod
    def should_update_data(self, **kwargs) -> bool:
        """Check if data should be updated."""
        pass

    @abstractmethod
    def download_and_cache_data(self, **kwargs) -> bool:
        """Download and cache vulnerability data."""
        pass

    @abstractmethod
    def lookup_vulnerability_info(self, cve_id: str, package_name: str, **kwargs) -> Optional[Dict]:
        """Look up vulnerability information."""
        pass

    @abstractmethod
    def get_package_vulnerabilities(self, package_name: str, **kwargs) -> List[Dict]:
        """Get all vulnerabilities for a package."""
        pass

    @abstractmethod
    def get_cache_stats(self) -> Dict:
        """Get statistics about cached data."""
        pass

    def enhance_vulnerability(self, vulnerability: Dict) -> Dict:
        """
        Enhance a vulnerability with data from this source.
        Default implementation - can be overridden by subclasses.
        """
        return vulnerability

    def force_update(self, **kwargs) -> bool:
        """Force an update of vulnerability data."""
        return self.download_and_cache_data(**kwargs)


class BaseOVALSource(BaseVulnerabilitySource):
    """Base class for OVAL-based vulnerability sources."""

    def __init__(self, source_name: str, distribution: str):
        super().__init__(source_name, "OVAL")
        self.distribution = distribution
        self.namespaces = {
            'oval': 'http://oval.mitre.org/XMLSchema/oval-common-5',
            'oval-def': 'http://oval.mitre.org/XMLSchema/oval-definitions-5',
            'unix-def': 'http://oval.mitre.org/XMLSchema/oval-definitions-5#unix',
            'linux-def': 'http://oval.mitre.org/XMLSchema/oval-definitions-5#linux'
        }

    @abstractmethod
    def get_oval_url(self, release: str) -> str:
        """Get the OVAL download URL for a specific release."""
        pass

    @abstractmethod
    def parse_oval_definition(self, definition_element: Any) -> Dict:
        """Parse an OVAL definition element."""
        pass

    @abstractmethod
    def extract_package_info(self, definition: Dict) -> List[Dict]:
        """Extract package information from an OVAL definition."""
        pass


class BaseUSNSource(BaseVulnerabilitySource):
    """Base class for USN-based vulnerability sources."""

    def __init__(self, source_name: str, distribution: str):
        super().__init__(source_name, "USN")
        self.distribution = distribution

    @abstractmethod
    def get_usn_url(self) -> str:
        """Get the USN API URL."""
        pass

    @abstractmethod
    def parse_usn_data(self, usn_data: Dict) -> List[Dict]:
        """Parse USN data into vulnerability records."""
        pass


class VulnerabilitySourceRegistry:
    """Registry for managing multiple vulnerability sources."""

    def __init__(self):
        self.sources: Dict[str, BaseVulnerabilitySource] = {}
        self.logger = logging.getLogger(f"{__name__}.Registry")

    def register_source(self, source: BaseVulnerabilitySource):
        """Register a vulnerability source."""
        self.sources[source.source_name] = source
        self.logger.info(f"Registered vulnerability source: {source.source_name}")

    def get_source(self, source_name: str) -> Optional[BaseVulnerabilitySource]:
        """Get a specific vulnerability source."""
        return self.sources.get(source_name)

    def get_sources_by_type(self, source_type: str) -> List[BaseVulnerabilitySource]:
        """Get all sources of a specific type."""
        return [source for source in self.sources.values() if source.source_type == source_type]

    def get_all_sources(self) -> List[BaseVulnerabilitySource]:
        """Get all registered sources."""
        return list(self.sources.values())

    def update_all_sources(self, **kwargs) -> Dict[str, bool]:
        """Update all registered sources."""
        results = {}
        for name, source in self.sources.items():
            try:
                if source.should_update_data(**kwargs):
                    results[name] = source.download_and_cache_data(**kwargs)
                else:
                    results[name] = True  # No update needed
                    self.logger.info(f"Source {name} is up to date")
            except Exception as e:
                self.logger.error(f"Error updating source {name}: {e}")
                results[name] = False
        return results


# Global registry instance
vulnerability_source_registry = VulnerabilitySourceRegistry()

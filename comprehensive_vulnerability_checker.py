#!/usr/bin/env python3

import sqlite3
import json
import re
import logging
from typing import Dict, List, Set
from packaging import version

logger = logging.getLogger(__name__)


class ComprehensiveVulnerabilityChecker:
    """Comprehensive vulnerability checker that dynamically identifies vulnerable packages."""

    def __init__(self, oval_db_path: str, cve_db_path: str):
        self.oval_db_path = oval_db_path
        self.cve_db_path = cve_db_path

    def get_installed_packages(self, vuls_result_file: str) -> Dict[str, str]:
        """Extract installed packages from Vuls scan result."""
        try:
            with open(vuls_result_file, "r") as f:
                data = json.load(f)

            packages = {}
            for pkg_name, pkg_info in data.get("packages", {}).items():
                version = pkg_info.get("version", "")
                packages[pkg_name] = version

            return packages

        except Exception as e:
            logger.error(f"Error reading Vuls result file: {e}")
            return {}

    def identify_vulnerable_packages(self, all_packages: Dict[str, str]) -> Set[str]:
        """Dynamically identify packages that commonly have vulnerabilities."""

        # Always scan these critical packages (if installed)
        critical_packages = {
            "openssl",
            "openssh-server",
            "openssh-client",
            "sudo",
            "systemd",
            "libc6",
            "libc-bin",
            "glibc",
            "bash",
            "curl",
            "wget",
            "git",
        }

        # High-risk package patterns
        high_risk_patterns = [
            # Network/Web/Security
            (r".*ssh.*", "SSH-related"),
            (r".*ssl.*", "SSL/TLS libraries"),
            (r".*tls.*", "TLS libraries"),
            (r".*crypto.*", "Cryptographic libraries"),
            (r".*crypt.*", "Cryptographic libraries"),
            (r".*http.*", "HTTP libraries"),
            (r".*curl.*", "HTTP clients"),
            (r".*wget.*", "HTTP clients"),
            (r".*nginx.*", "Web servers"),
            (r".*apache.*", "Web servers"),
            # Languages/Runtimes
            (r".*java.*", "Java runtime"),
            (r".*jdk.*", "Java development kit"),
            (r".*jre.*", "Java runtime environment"),
            (r".*openjdk.*", "OpenJDK"),
            (r".*python.*", "Python runtime"),
            (r".*perl.*", "Perl runtime"),
            (r".*php.*", "PHP runtime"),
            (r".*ruby.*", "Ruby runtime"),
            (r".*node.*", "Node.js runtime"),
            # Databases
            (r".*sql.*", "Database systems"),
            (r".*maria.*", "MariaDB"),
            (r".*mysql.*", "MySQL"),
            (r".*postgres.*", "PostgreSQL"),
            (r".*redis.*", "Redis"),
            (r".*mongo.*", "MongoDB"),
            # Containers/Virtualization
            (r".*docker.*", "Docker containers"),
            (r".*container.*", "Container runtime"),
            (r".*containerd.*", "Container daemon"),
            (r".*runc.*", "Container runtime"),
            # System/Security
            (r".*sudo.*", "Privilege escalation"),
            (r".*systemd.*", "System daemon"),
            (r".*pam.*", "Authentication"),
            (r".*auth.*", "Authentication"),
            (r".*login.*", "Login systems"),
            (r".*shadow.*", "Password management"),
            # Parsers/Libraries (often vulnerable)
            (r".*xml.*", "XML parsers"),
            (r".*json.*", "JSON parsers"),
            (r".*yaml.*", "YAML parsers"),
            (r".*expat.*", "XML parser"),
            (r".*libxml.*", "XML library"),
            (r".*parser.*", "Parser libraries"),
            # Network libraries
            (r".*gnutls.*", "TLS library"),
            (r".*nettle.*", "Crypto library"),
            (r".*gcrypt.*", "Crypto library"),
            # Mail/DNS
            (r".*mail.*", "Mail systems"),
            (r".*smtp.*", "SMTP servers"),
            (r".*exim.*", "Exim mail server"),
            (r".*postfix.*", "Postfix mail server"),
            (r".*bind.*", "DNS server"),
            (r".*dns.*", "DNS systems"),
            # Archive/Compression
            (r".*zip.*", "Archive libraries"),
            (r".*tar.*", "Archive tools"),
            (r".*gzip.*", "Compression"),
            (r".*bzip.*", "Compression"),
            (r".*xz.*", "Compression"),
        ]

        vulnerable_packages = set(critical_packages)

        # Add packages matching high-risk patterns
        for pkg_name in all_packages.keys():
            for pattern, category in high_risk_patterns:
                if re.match(pattern, pkg_name, re.IGNORECASE):
                    vulnerable_packages.add(pkg_name)
                    logger.debug(f"Added {pkg_name} (matched {category})")
                    break

        # Filter to only packages that are actually installed
        installed_vulnerable = {
            pkg for pkg in vulnerable_packages if pkg in all_packages
        }

        logger.info(
            f"Identified {len(installed_vulnerable)} potentially vulnerable packages out of {len(all_packages)} total"
        )

        return installed_vulnerable

    def check_comprehensive_vulnerabilities(
        self, all_packages: Dict[str, str]
    ) -> List[Dict]:
        """Check vulnerabilities across all potentially vulnerable packages."""

        # Identify packages to scan
        packages_to_scan = self.identify_vulnerable_packages(all_packages)

        print(f"Scanning {len(packages_to_scan)} potentially vulnerable packages...")

        vulnerabilities = []
        scanned_count = 0

        try:
            with sqlite3.connect(self.oval_db_path) as conn:
                cursor = conn.cursor()

                for package_name in sorted(packages_to_scan):
                    if package_name in all_packages:
                        version = all_packages[package_name]
                        vulns = self._query_package_precisely(
                            cursor, package_name, version
                        )

                        if vulns:
                            vulnerabilities.extend(vulns)
                            print(
                                f"Found {len(vulns)} vulnerabilities for {package_name} {version}"
                            )

                        scanned_count += 1

                        # Progress indicator
                        if scanned_count % 10 == 0:
                            print(
                                f"Scanned {scanned_count}/{len(packages_to_scan)} packages..."
                            )

            return vulnerabilities

        except Exception as e:
            logger.error(f"Error checking vulnerabilities: {e}")
            return []

    def _query_package_precisely(
        self, cursor, package_name: str, installed_version: str
    ) -> List[Dict]:
        """Query with precise package name matching and version comparison."""
        vulnerabilities = []

        try:
            # Query to get CVE definitions and their fixed versions
            query = """
            SELECT DISTINCT d.definition_id, d.title, d.description, p.version as fixed_version
            FROM definitions d
            JOIN debians deb ON d.id = deb.definition_id
            JOIN packages p ON d.id = p.definition_id
            WHERE d.root_id = 3
            AND p.name = ?
            AND (d.title LIKE ? OR d.title LIKE ?)
            ORDER BY d.definition_id DESC
            """

            pattern1 = f"% {package_name} %"
            pattern2 = f"% {package_name}"

            cursor.execute(query, (package_name, pattern1, pattern2))

            for row in cursor.fetchall():
                definition_id, title, description, fixed_version = row

                # Additional validation
                if not self._is_really_about_package(title, description, package_name):
                    continue

                # Extract CVE ID
                cve_match = re.search(r"CVE-\d{4}-\d{4,}", title)
                if not cve_match:
                    continue

                cve_id = cve_match.group(0)

                # Only include recent CVEs (2018+) to reduce noise
                year_match = re.search(r"CVE-(\d{4})", cve_id)
                if year_match and int(year_match.group(1)) < 2018:
                    continue

                # VERSION COMPARISON: Check if installed version is vulnerable
                if not self._is_version_vulnerable(installed_version, fixed_version):
                    logger.debug(f"Skipping {cve_id} for {package_name}: installed version {installed_version} >= fixed version {fixed_version}")
                    continue

                # SANITY CHECK: Skip very old CVEs for very new software versions
                if self._is_version_too_new_for_cve(installed_version, cve_id):
                    logger.debug(f"Skipping {cve_id} for {package_name}: installed version {installed_version} is too new for this old CVE")
                    continue

                # Get CVE details
                cve_details = self._get_cve_details(cve_id)

                vulnerability = {
                    "cve_id": cve_id,
                    "definition_id": definition_id,
                    "title": title,
                    "description": description or "",
                    "affected_package": package_name,
                    "installed_version": installed_version,
                    "fixed_version": fixed_version,
                    "cvss_score": cve_details.get("cvss_score", 0.0),
                    "severity": cve_details.get("severity", "unknown"),
                    "summary": cve_details.get("summary", ""),
                    "published_date": cve_details.get("published_date", ""),
                }

                vulnerabilities.append(vulnerability)
                logger.info(f"Found vulnerability {cve_id} for {package_name}: {installed_version} < {fixed_version}")

        except Exception as e:
            logger.warning(f"Error querying package {package_name}: {e}")

        return vulnerabilities

    def _is_version_vulnerable(self, installed_version: str, fixed_version: str) -> bool:
        """
        Check if the installed version is vulnerable compared to the fixed version.
        Returns True if installed version is older (vulnerable), False if newer/equal (safe).
        """
        try:
            # Clean up version strings for comparison
            installed_clean = self._clean_debian_version(installed_version)
            fixed_clean = self._clean_debian_version(fixed_version)

            # Use packaging library for version comparison
            installed_ver = version.parse(installed_clean)
            fixed_ver = version.parse(fixed_clean)

            # If installed version is less than fixed version, it's vulnerable
            is_vulnerable = installed_ver < fixed_ver

            logger.debug(f"Version comparison: {installed_version} ({installed_clean}) {'<' if is_vulnerable else '>='} {fixed_version} ({fixed_clean}) = {'VULNERABLE' if is_vulnerable else 'SAFE'}")

            return is_vulnerable

        except Exception as e:
            logger.warning(f"Error comparing versions {installed_version} vs {fixed_version}: {e}")
            # If we can't compare versions, err on the side of caution and include it
            return True

    def _clean_debian_version(self, version_str: str) -> str:
        """
        Clean Debian version string for comparison.
        Examples:
        - "7.88.1-10+deb12u12" -> "7.88.1"
        - "7.61.0-1" -> "7.61.0"
        - "5.2.15-2+b8" -> "5.2.15"
        - "5.1~rc1-2" -> "5.1.0rc1"
        - "3.11.2-6+deb12u6" -> "3.11.2"
        - "3.11.0~b4-1" -> "3.11.0b4"
        """
        if not version_str:
            return "0"

        # Handle special Debian version characters
        # Replace ~ with . for pre-release versions (5.1~rc1 -> 5.1.rc1)
        cleaned = version_str.replace('~', '.')

        # Remove everything after the first dash (Debian revision)
        base_version = cleaned.split('-')[0]

        # Handle special cases for pre-release versions
        # Convert rc, alpha, beta to formats that packaging can understand
        base_version = re.sub(r'\.rc(\d+)', r'rc\1', base_version)  # .rc1 -> rc1
        base_version = re.sub(r'\.b(\d+)', r'b\1', base_version)    # .b4 -> b4
        base_version = re.sub(r'\.a(\d+)', r'a\1', base_version)    # .a1 -> a1

        # Remove any remaining non-version characters except rc, a, b for pre-releases
        cleaned = re.sub(r'[^0-9.rcab]', '', base_version)

        # Ensure we have a valid version string
        if not cleaned or cleaned == '.':
            return "0"

        return cleaned

    def _is_version_too_new_for_cve(self, installed_version: str, cve_id: str) -> bool:
        """
        Check if the installed version is too new to be affected by an old CVE.
        This helps filter out false positives from OVAL database inconsistencies.
        """
        try:
            # Extract CVE year
            year_match = re.search(r"CVE-(\d{4})", cve_id)
            if not year_match:
                return False

            cve_year = int(year_match.group(1))

            # Extract major version from installed package
            installed_clean = self._clean_debian_version(installed_version)
            version_parts = installed_clean.split('.')

            if not version_parts:
                return False

            try:
                major_version = int(version_parts[0])
            except ValueError:
                return False

            # Heuristic: If CVE is from 2018 and installed version is 3.x (released ~2021+),
            # it's likely a false positive
            if cve_year <= 2018 and major_version >= 3:
                return True

            # For very old CVEs (pre-2020) and very new major versions
            if cve_year <= 2019 and major_version >= 4:
                return True

            return False

        except Exception as e:
            logger.debug(f"Error in version age check for {cve_id}: {e}")
            return False

    def _is_really_about_package(
        self, title: str, description: str, package_name: str
    ) -> bool:
        """Conservative check if vulnerability is really about this package."""
        title_lower = title.lower()
        package_lower = package_name.lower()

        # Must have package name in title
        if package_lower not in title_lower:
            return False

        # Skip if it's clearly about something else
        false_indicators = [
            "linux",
            "kernel",
            "driver",
            "firmware",
            "bios",
            "windows",
            "android",
            "ios",
            "macos",
        ]

        for indicator in false_indicators:
            if indicator in title_lower and package_lower != indicator:
                return False

        return True

    def _get_cve_details(self, cve_id: str) -> Dict:
        """Get CVE details from CVE database."""
        try:
            with sqlite3.connect(self.cve_db_path) as conn:
                cursor = conn.cursor()

                cursor.execute(
                    """
                    SELECT
                        n.cve_id,
                        n.published_date,
                        c3.base_score,
                        c3.base_severity,
                        d.value as description
                    FROM nvds n
                    LEFT JOIN nvd_cvss3 c3 ON n.id = c3.nvd_id
                    LEFT JOIN nvd_descriptions d ON n.id = d.nvd_id AND d.lang = 'en'
                    WHERE n.cve_id = ?
                    LIMIT 1
                """,
                    (cve_id,),
                )

                row = cursor.fetchone()
                if row:
                    return {
                        "published_date": row[1],
                        "cvss_score": row[2] if row[2] else 0.0,
                        "severity": row[3] if row[3] else "unknown",
                        "summary": row[4] if row[4] else "",
                    }
        except Exception as e:
            logger.debug(f"Could not get CVE details for {cve_id}: {e}")

        return {}

    def generate_comprehensive_report(self, vulnerabilities: List[Dict]) -> Dict:
        """Generate comprehensive vulnerability report."""
        if not vulnerabilities:
            return {
                "total_vulnerabilities": 0,
                "packages_affected": 0,
                "vulnerability_breakdown": {},
                "high_risk_packages": [],
                "vulnerabilities": [],
            }

        # Group by package and severity
        by_package = {}
        by_severity = {"CRITICAL": 0, "HIGH": 0, "MEDIUM": 0, "LOW": 0, "unknown": 0}

        for vuln in vulnerabilities:
            # By package
            pkg = vuln["affected_package"]
            if pkg not in by_package:
                by_package[pkg] = {
                    "total": 0,
                    "critical": 0,
                    "high": 0,
                    "medium": 0,
                    "low": 0,
                }

            by_package[pkg]["total"] += 1
            severity = vuln.get("severity", "unknown").upper()

            # Fix: Map severity to correct field names
            severity_mapping = {
                "CRITICAL": "critical",
                "HIGH": "high",
                "MEDIUM": "medium",
                "LOW": "low"
            }

            if severity in severity_mapping:
                by_package[pkg][severity_mapping[severity]] += 1

            # By severity
            if severity in by_severity:
                by_severity[severity] += 1
            else:
                by_severity["unknown"] += 1

        # Calculate risk scores
        high_risk_packages = []
        for pkg, counts in by_package.items():
            risk_score = (
                counts["critical"] * 20
                + counts["high"] * 10
                + counts["medium"] * 5
                + counts["low"] * 1
            )

            high_risk_packages.append(
                {
                    "package": pkg,
                    "total_vulns": counts["total"],
                    "critical": counts["critical"],
                    "high": counts["high"],
                    "medium": counts["medium"],
                    "low": counts["low"],
                    "risk_score": risk_score,
                }
            )

        high_risk_packages.sort(key=lambda x: x["risk_score"], reverse=True)

        return {
            "total_vulnerabilities": len(vulnerabilities),
            "packages_affected": len(by_package),
            "vulnerability_breakdown": by_severity,
            "high_risk_packages": high_risk_packages,
            "vulnerabilities": vulnerabilities,
        }


def main():
    """CLI interface for comprehensive vulnerability checking."""
    import argparse

    parser = argparse.ArgumentParser(description="Comprehensive vulnerability checker")
    parser.add_argument(
        "--vuls-result", required=True, help="Path to Vuls scan result JSON"
    )
    parser.add_argument(
        "--oval-db", default="./db/oval.sqlite3", help="Path to OVAL database"
    )
    parser.add_argument(
        "--cve-db", default="./db/cve.sqlite3", help="Path to CVE database"
    )
    parser.add_argument("--output", help="Output JSON file")

    args = parser.parse_args()

    checker = ComprehensiveVulnerabilityChecker(args.oval_db, args.cve_db)

    # Get installed packages
    packages = checker.get_installed_packages(args.vuls_result)
    print(f"Found {len(packages)} total installed packages")

    # Check vulnerabilities comprehensively
    vulnerabilities = checker.check_comprehensive_vulnerabilities(packages)

    # Generate report
    report = checker.generate_comprehensive_report(vulnerabilities)

    print(f"\n🔍 COMPREHENSIVE VULNERABILITY SCAN RESULTS:")
    print(f"   Total vulnerabilities: {report['total_vulnerabilities']}")
    print(f"   Packages affected: {report['packages_affected']}")
    print(f"   Breakdown: {report['vulnerability_breakdown']}")

    if args.output:
        with open(args.output, "w") as f:
            json.dump(report, f, indent=2)
        print(f"\nReport saved to {args.output}")

    return report


if __name__ == "__main__":
    main()

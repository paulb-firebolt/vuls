"""Enhanced vulnerability checker service integrated for the web application."""

import sqlite3
import json
import re
import logging
from typing import Dict, List, Set
from packaging import version
from pathlib import Path

logger = logging.getLogger(__name__)


class EnhancedVulnerabilityChecker:
    """Enhanced vulnerability checker that uses both OVAL and GOST databases."""

    def __init__(self, oval_db_path: str, gost_db_path: str, cve_db_path: str):
        self.oval_db_path = oval_db_path
        self.gost_db_path = gost_db_path
        self.cve_db_path = cve_db_path

    def get_installed_packages(self, vuls_result_file: str) -> Dict[str, str]:
        """Extract installed packages from Vuls scan result."""
        try:
            with open(vuls_result_file, "r") as f:
                data = json.load(f)

            packages = {}

            # Handle both single server and multiple server formats
            if isinstance(data, dict):
                # Check if this is a direct server data or contains servers
                if "packages" in data:
                    # Direct server data
                    for pkg_name, pkg_info in data.get("packages", {}).items():
                        version = pkg_info.get("version", "")
                        packages[pkg_name] = version
                else:
                    # Multiple servers format
                    for server_name, server_data in data.items():
                        if isinstance(server_data, dict) and "packages" in server_data:
                            for pkg_name, pkg_info in server_data.get("packages", {}).items():
                                version = pkg_info.get("version", "")
                                packages[pkg_name] = version

            logger.info(f"Extracted {len(packages)} packages from Vuls result")
            return packages

        except Exception as e:
            logger.error(f"Error reading Vuls result file: {e}")
            return {}

    def identify_vulnerable_packages(self, all_packages: Dict[str, str]) -> Set[str]:
        """Dynamically identify packages that commonly have vulnerabilities."""

        # Always scan these critical packages (if installed)
        critical_packages = {
            "openssl",
            "openssh-server",
            "openssh-client",
            "sudo",
            "systemd",
            "libc6",
            "libc-bin",
            "glibc",
            "bash",
            "curl",
            "wget",
            "git",
        }

        # High-risk package patterns
        high_risk_patterns = [
            # Network/Web/Security
            (r".*ssh.*", "SSH-related"),
            (r".*ssl.*", "SSL/TLS libraries"),
            (r".*tls.*", "TLS libraries"),
            (r".*crypto.*", "Cryptographic libraries"),
            (r".*crypt.*", "Cryptographic libraries"),
            (r".*http.*", "HTTP libraries"),
            (r".*curl.*", "HTTP clients"),
            (r".*wget.*", "HTTP clients"),
            (r".*nginx.*", "Web servers"),
            (r".*apache.*", "Web servers"),
            # Languages/Runtimes
            (r".*java.*", "Java runtime"),
            (r".*jdk.*", "Java development kit"),
            (r".*jre.*", "Java runtime environment"),
            (r".*openjdk.*", "OpenJDK"),
            (r".*python.*", "Python runtime"),
            (r".*perl.*", "Perl runtime"),
            (r".*php.*", "PHP runtime"),
            (r".*ruby.*", "Ruby runtime"),
            (r".*node.*", "Node.js runtime"),
            # Databases
            (r".*sql.*", "Database systems"),
            (r".*maria.*", "MariaDB"),
            (r".*mysql.*", "MySQL"),
            (r".*postgres.*", "PostgreSQL"),
            (r".*redis.*", "Redis"),
            (r".*mongo.*", "MongoDB"),
            # Containers/Virtualization
            (r".*docker.*", "Docker containers"),
            (r".*container.*", "Container runtime"),
            (r".*containerd.*", "Container daemon"),
            (r".*runc.*", "Container runtime"),
            # System/Security
            (r".*sudo.*", "Privilege escalation"),
            (r".*systemd.*", "System daemon"),
            (r".*pam.*", "Authentication"),
            (r".*auth.*", "Authentication"),
            (r".*login.*", "Login systems"),
            (r".*shadow.*", "Password management"),
            # Parsers/Libraries (often vulnerable)
            (r".*xml.*", "XML parsers"),
            (r".*json.*", "JSON parsers"),
            (r".*yaml.*", "YAML parsers"),
            (r".*expat.*", "XML parser"),
            (r".*libxml.*", "XML library"),
            (r".*parser.*", "Parser libraries"),
            # Network libraries
            (r".*gnutls.*", "TLS library"),
            (r".*nettle.*", "Crypto library"),
            (r".*gcrypt.*", "Crypto library"),
            # Mail/DNS
            (r".*mail.*", "Mail systems"),
            (r".*smtp.*", "SMTP servers"),
            (r".*exim.*", "Exim mail server"),
            (r".*postfix.*", "Postfix mail server"),
            (r".*bind.*", "DNS server"),
            (r".*dns.*", "DNS systems"),
            # Archive/Compression
            (r".*zip.*", "Archive libraries"),
            (r".*tar.*", "Archive tools"),
            (r".*gzip.*", "Compression"),
            (r".*bzip.*", "Compression"),
            (r".*xz.*", "Compression"),
        ]

        vulnerable_packages = set(critical_packages)

        # Add packages matching high-risk patterns
        for pkg_name in all_packages.keys():
            for pattern, category in high_risk_patterns:
                if re.match(pattern, pkg_name, re.IGNORECASE):
                    vulnerable_packages.add(pkg_name)
                    logger.debug(f"Added {pkg_name} (matched {category})")
                    break

        # Filter to only packages that are actually installed
        installed_vulnerable = {
            pkg for pkg in vulnerable_packages if pkg in all_packages
        }

        logger.info(
            f"Identified {len(installed_vulnerable)} potentially vulnerable packages out of {len(all_packages)} total"
        )

        return installed_vulnerable

    def check_enhanced_vulnerabilities(self, all_packages: Dict[str, str]) -> List[Dict]:
        """Check vulnerabilities using both OVAL and GOST databases."""

        # Identify packages to scan
        packages_to_scan = self.identify_vulnerable_packages(all_packages)

        logger.info(f"Scanning {len(packages_to_scan)} potentially vulnerable packages using OVAL and GOST...")

        vulnerabilities = []

        # Check OVAL database
        oval_vulns = self._check_oval_vulnerabilities(packages_to_scan, all_packages)
        vulnerabilities.extend(oval_vulns)
        logger.info(f"Found {len(oval_vulns)} vulnerabilities from OVAL database")

        # Check GOST database
        gost_vulns = self._check_gost_vulnerabilities(packages_to_scan, all_packages)
        vulnerabilities.extend(gost_vulns)
        logger.info(f"Found {len(gost_vulns)} vulnerabilities from GOST database")

        # Deduplicate vulnerabilities (same CVE for same package)
        deduplicated = self._deduplicate_vulnerabilities(vulnerabilities)
        logger.info(f"After deduplication: {len(deduplicated)} unique vulnerabilities")

        return deduplicated

    def _check_oval_vulnerabilities(self, packages_to_scan: Set[str], all_packages: Dict[str, str]) -> List[Dict]:
        """Check vulnerabilities using OVAL database."""
        vulnerabilities = []

        try:
            with sqlite3.connect(self.oval_db_path) as conn:
                cursor = conn.cursor()

                for package_name in sorted(packages_to_scan):
                    if package_name in all_packages:
                        version = all_packages[package_name]
                        vulns = self._query_oval_package(cursor, package_name, version)
                        vulnerabilities.extend(vulns)

        except Exception as e:
            logger.error(f"Error checking OVAL vulnerabilities: {e}")

        return vulnerabilities

    def _check_gost_vulnerabilities(self, packages_to_scan: Set[str], all_packages: Dict[str, str]) -> List[Dict]:
        """Check vulnerabilities using GOST database."""
        vulnerabilities = []

        try:
            with sqlite3.connect(self.gost_db_path) as conn:
                cursor = conn.cursor()

                for package_name in sorted(packages_to_scan):
                    if package_name in all_packages:
                        version = all_packages[package_name]
                        vulns = self._query_gost_package(cursor, package_name, version)
                        vulnerabilities.extend(vulns)

        except Exception as e:
            logger.error(f"Error checking GOST vulnerabilities: {e}")

        return vulnerabilities

    def _query_oval_package(self, cursor, package_name: str, installed_version: str) -> List[Dict]:
        """Query OVAL database for package vulnerabilities."""
        vulnerabilities = []

        try:
            # Query to get CVE definitions and their fixed versions
            query = """
            SELECT DISTINCT d.definition_id, d.title, d.description, p.version as fixed_version
            FROM definitions d
            JOIN debians deb ON d.id = deb.definition_id
            JOIN packages p ON d.id = p.definition_id
            WHERE d.root_id = 3
            AND p.name = ?
            AND (d.title LIKE ? OR d.title LIKE ?)
            ORDER BY d.definition_id DESC
            """

            pattern1 = f"% {package_name} %"
            pattern2 = f"% {package_name}"

            cursor.execute(query, (package_name, pattern1, pattern2))

            for row in cursor.fetchall():
                definition_id, title, description, fixed_version = row

                # Additional validation
                if not self._is_really_about_package(title, description, package_name):
                    continue

                # Extract CVE ID
                cve_match = re.search(r"CVE-\d{4}-\d{4,}", title)
                if not cve_match:
                    continue

                cve_id = cve_match.group(0)

                # Only include recent CVEs (2018+) to reduce noise
                year_match = re.search(r"CVE-(\d{4})", cve_id)
                if year_match and int(year_match.group(1)) < 2018:
                    continue

                # VERSION COMPARISON: Check if installed version is vulnerable
                if not self._is_version_vulnerable(installed_version, fixed_version):
                    continue

                # Get CVE details
                cve_details = self._get_cve_details(cve_id)

                vulnerability = {
                    "cve_id": cve_id,
                    "source": "OVAL",
                    "definition_id": definition_id,
                    "title": title,
                    "description": description or "",
                    "affected_package": package_name,
                    "installed_version": installed_version,
                    "fixed_version": fixed_version,
                    "cvss_score": cve_details.get("cvss_score", 0.0),
                    "severity": cve_details.get("severity", "unknown"),
                    "summary": cve_details.get("summary", ""),
                    "published_date": cve_details.get("published_date", ""),
                }

                vulnerabilities.append(vulnerability)

        except Exception as e:
            logger.warning(f"Error querying OVAL for package {package_name}: {e}")

        return vulnerabilities

    def _query_gost_package(self, cursor, package_name: str, installed_version: str) -> List[Dict]:
        """Query GOST database for package vulnerabilities using correct Ubuntu schema."""
        vulnerabilities = []

        try:
            # Query using the correct GOST Ubuntu schema
            query = """
            SELECT DISTINCT
                c.candidate as cve_id,
                c.priority,
                c.description,
                c.public_date,
                p.package_name
            FROM ubuntu_cves c
            JOIN ubuntu_patches p ON c.id = p.ubuntu_cve_id
            WHERE p.package_name = ?
            AND c.candidate LIKE 'CVE-%'
            ORDER BY c.candidate DESC
            """

            cursor.execute(query, (package_name,))
            rows = cursor.fetchall()

            for row in rows:
                cve_id = row[0]
                priority = row[1] or "unknown"
                description = row[2] or ""
                public_date = row[3] or ""

                # Skip if no CVE ID
                if not cve_id or not cve_id.startswith('CVE-'):
                    continue

                # Only include recent CVEs (2018+) to reduce noise
                year_match = re.search(r"CVE-(\d{4})", cve_id)
                if year_match and int(year_match.group(1)) < 2018:
                    continue

                # Get CVE details from the CVE database
                cve_details = self._get_cve_details(cve_id)

                vulnerability = {
                    "cve_id": cve_id,
                    "source": "GOST",
                    "affected_package": package_name,
                    "installed_version": installed_version,
                    "fixed_version": "unknown",  # GOST doesn't provide this directly
                    "priority": priority,
                    "description": description,
                    "public_date": public_date,
                    "cvss_score": cve_details.get("cvss_score", 0.0),
                    "severity": cve_details.get("severity", priority),
                    "summary": cve_details.get("summary", description),
                    "published_date": cve_details.get("published_date", public_date),
                }

                vulnerabilities.append(vulnerability)

        except Exception as e:
            logger.warning(f"Error querying GOST for package {package_name}: {e}")

        return vulnerabilities

    def _deduplicate_vulnerabilities(self, vulnerabilities: List[Dict]) -> List[Dict]:
        """Remove duplicate vulnerabilities (same CVE for same package)."""
        seen = set()
        deduplicated = []

        for vuln in vulnerabilities:
            key = (vuln["cve_id"], vuln["affected_package"])
            if key not in seen:
                seen.add(key)
                deduplicated.append(vuln)
            else:
                # If we have a duplicate, prefer OVAL over GOST (more detailed)
                existing_idx = None
                for i, existing in enumerate(deduplicated):
                    if (existing["cve_id"], existing["affected_package"]) == key:
                        existing_idx = i
                        break

                if existing_idx is not None:
                    existing = deduplicated[existing_idx]
                    if vuln["source"] == "OVAL" and existing["source"] == "GOST":
                        # Replace GOST with OVAL
                        deduplicated[existing_idx] = vuln
                    elif vuln["source"] == "GOST" and existing["source"] == "OVAL":
                        # Keep OVAL, skip GOST
                        continue

        return deduplicated

    def _is_version_vulnerable(self, installed_version: str, fixed_version: str) -> bool:
        """
        Check if the installed version is vulnerable compared to the fixed version.
        Returns True if installed version is older (vulnerable), False if newer/equal (safe).
        """
        try:
            # Clean up version strings for comparison
            installed_clean = self._clean_debian_version(installed_version)
            fixed_clean = self._clean_debian_version(fixed_version)

            # Use packaging library for version comparison
            installed_ver = version.parse(installed_clean)
            fixed_ver = version.parse(fixed_clean)

            # If installed version is less than fixed version, it's vulnerable
            is_vulnerable = installed_ver < fixed_ver

            return is_vulnerable

        except Exception as e:
            logger.warning(f"Error comparing versions {installed_version} vs {fixed_version}: {e}")
            # If we can't compare versions, err on the side of caution and include it
            return True

    def _clean_debian_version(self, version_str: str) -> str:
        """
        Clean Debian version string for comparison.
        Examples:
        - "7.88.1-10+deb12u12" -> "7.88.1"
        - "7.61.0-1" -> "7.61.0"
        - "5.2.15-2+b8" -> "5.2.15"
        - "5.1~rc1-2" -> "5.1.0rc1"
        - "3.11.2-6+deb12u6" -> "3.11.2"
        - "3.11.0~b4-1" -> "3.11.0b4"
        """
        if not version_str:
            return "0"

        # Handle special Debian version characters
        # Replace ~ with . for pre-release versions (5.1~rc1 -> 5.1.rc1)
        cleaned = version_str.replace("~", ".")

        # Remove everything after the first dash (Debian revision)
        base_version = cleaned.split("-")[0]

        # Handle special cases for pre-release versions
        # Convert rc, alpha, beta to formats that packaging can understand
        base_version = re.sub(r"\.rc(\d+)", r"rc\1", base_version)  # .rc1 -> rc1
        base_version = re.sub(r"\.b(\d+)", r"b\1", base_version)    # .b4 -> b4
        base_version = re.sub(r"\.a(\d+)", r"a\1", base_version)    # .a1 -> a1

        # Remove any remaining non-version characters except rc, a, b for pre-releases
        cleaned = re.sub(r"[^0-9.rcab]", "", base_version)

        # Ensure we have a valid version string
        if not cleaned or cleaned == ".":
            return "0"

        return cleaned

    def _is_really_about_package(self, title: str, description: str, package_name: str) -> bool:
        """Conservative check if vulnerability is really about this package."""
        title_lower = title.lower()
        package_lower = package_name.lower()

        # Must have package name in title
        if package_lower not in title_lower:
            return False

        # Skip if it's clearly about something else
        false_indicators = [
            "linux",
            "kernel",
            "driver",
            "firmware",
            "bios",
            "windows",
            "android",
            "ios",
            "macos",
        ]

        for indicator in false_indicators:
            if indicator in title_lower and package_lower != indicator:
                return False

        return True

    def _get_cve_details(self, cve_id: str) -> Dict:
        """Get CVE details from CVE database."""
        try:
            with sqlite3.connect(self.cve_db_path) as conn:
                cursor = conn.cursor()

                cursor.execute(
                    """
                    SELECT
                        n.cve_id,
                        n.published_date,
                        c3.base_score,
                        c3.base_severity,
                        d.value as description
                    FROM nvds n
                    LEFT JOIN nvd_cvss3 c3 ON n.id = c3.nvd_id
                    LEFT JOIN nvd_descriptions d ON n.id = d.nvd_id AND d.lang = 'en'
                    WHERE n.cve_id = ?
                    LIMIT 1
                """,
                    (cve_id,),
                )

                row = cursor.fetchone()
                if row:
                    return {
                        "published_date": row[1],
                        "cvss_score": row[2] if row[2] else 0.0,
                        "severity": row[3] if row[3] else "unknown",
                        "summary": row[4] if row[4] else "",
                    }
        except Exception as e:
            logger.debug(f"Could not get CVE details for {cve_id}: {e}")

        return {}

    def generate_enhanced_report(self, vulnerabilities: List[Dict]) -> Dict:
        """Generate enhanced vulnerability report."""
        if not vulnerabilities:
            return {
                "total_vulnerabilities": 0,
                "packages_affected": 0,
                "vulnerability_breakdown": {},
                "source_breakdown": {},
                "high_risk_packages": [],
                "vulnerabilities": [],
            }

        # Group by package, severity, and source
        by_package = {}
        by_severity = {"CRITICAL": 0, "HIGH": 0, "MEDIUM": 0, "LOW": 0, "unknown": 0}
        by_source = {"OVAL": 0, "GOST": 0}

        for vuln in vulnerabilities:
            # By package
            pkg = vuln["affected_package"]
            if pkg not in by_package:
                by_package[pkg] = {
                    "total": 0,
                    "critical": 0,
                    "high": 0,
                    "medium": 0,
                    "low": 0,
                    "oval_count": 0,
                    "gost_count": 0,
                }

            by_package[pkg]["total"] += 1
            severity = vuln.get("severity", "unknown").upper()

            # Map severity to correct field names
            severity_mapping = {
                "CRITICAL": "critical",
                "HIGH": "high",
                "MEDIUM": "medium",
                "LOW": "low"
            }

            if severity in severity_mapping:
                by_package[pkg][severity_mapping[severity]] += 1

            # By severity
            if severity in by_severity:
                by_severity[severity] += 1
            else:
                by_severity["unknown"] += 1

            # By source
            source = vuln.get("source", "unknown")
            if source in by_source:
                by_source[source] += 1
                by_package[pkg][f"{source.lower()}_count"] += 1

        # Calculate risk scores
        high_risk_packages = []
        for pkg, counts in by_package.items():
            risk_score = (
                counts["critical"] * 20
                + counts["high"] * 10
                + counts["medium"] * 5
                + counts["low"] * 1
            )

            high_risk_packages.append(
                {
                    "package": pkg,
                    "total_vulns": counts["total"],
                    "critical": counts["critical"],
                    "high": counts["high"],
                    "medium": counts["medium"],
                    "low": counts["low"],
                    "oval_count": counts["oval_count"],
                    "gost_count": counts["gost_count"],
                    "risk_score": risk_score,
                }
            )

        high_risk_packages.sort(key=lambda x: x["risk_score"], reverse=True)

        return {
            "total_vulnerabilities": len(vulnerabilities),
            "packages_affected": len(by_package),
            "vulnerability_breakdown": by_severity,
            "source_breakdown": by_source,
            "high_risk_packages": high_risk_packages,
            "vulnerabilities": vulnerabilities,
        }

#!/usr/bin/env python3

import sqlite3
import json
import re
import logging
from datetime import datetime
from typing import Dict, List, Optional

logger = logging.getLogger(__name__)


class SimpleVulnerabilityChecker:
    """A more conservative vulnerability checker that avoids false positives."""

    def __init__(self, oval_db_path: str, cve_db_path: str):
        self.oval_db_path = oval_db_path
        self.cve_db_path = cve_db_path

    def get_installed_packages(self, vuls_result_file: str) -> Dict[str, str]:
        """Extract installed packages from Vuls scan result."""
        try:
            with open(vuls_result_file, "r") as f:
                data = json.load(f)

            packages = {}
            for pkg_name, pkg_info in data.get("packages", {}).items():
                version = pkg_info.get("version", "")
                packages[pkg_name] = version

            return packages

        except Exception as e:
            logger.error(f"Error reading Vuls result file: {e}")
            return {}

    def check_specific_packages(
        self, packages: Dict[str, str], package_list: List[str] = None
    ) -> List[Dict]:
        """Check only specific high-risk packages to avoid false positives."""
        if package_list is None:
            # Focus on commonly vulnerable packages
            package_list = [
                "openssl",
                "openssh-server",
                "openssh-client",
                "curl",
                "wget",
                "nginx",
                "apache2",
                "php",
                "python3",
                "perl",
                "git",
                "sudo",
                "systemd",
                "glibc",
                "libc6",
                "libssl3",
                "bash",
            ]

        vulnerabilities = []

        try:
            with sqlite3.connect(self.oval_db_path) as conn:
                cursor = conn.cursor()

                for package_name in package_list:
                    if package_name in packages:
                        version = packages[package_name]
                        vulns = self._query_package_precisely(
                            cursor, package_name, version
                        )
                        vulnerabilities.extend(vulns)

                        if vulns:
                            print(
                                f"Found {len(vulns)} vulnerabilities for {package_name} {version}"
                            )

            return vulnerabilities

        except Exception as e:
            logger.error(f"Error checking vulnerabilities: {e}")
            return []

    def _query_package_precisely(
        self, cursor, package_name: str, version: str
    ) -> List[Dict]:
        """Query with very precise package name matching."""
        vulnerabilities = []

        try:
            # Use simpler LIKE patterns for SQLite compatibility
            query = """
            SELECT DISTINCT d.definition_id, d.title, d.description
            FROM definitions d 
            JOIN debians deb ON d.id = deb.definition_id 
            WHERE d.root_id = 3 
            AND (d.title LIKE ? OR d.title LIKE ?)
            ORDER BY d.definition_id DESC
            LIMIT 20
            """

            # Use LIKE patterns for word boundaries
            pattern1 = f"% {package_name} %"  # " package "
            pattern2 = f"% {package_name}"  # " package" at end

            cursor.execute(query, (pattern1, pattern2))

            for row in cursor.fetchall():
                definition_id, title, description = row

                # Additional validation
                if not self._is_really_about_package(title, description, package_name):
                    continue

                # Extract CVE ID
                cve_match = re.search(r"CVE-\d{4}-\d{4,}", title)
                if not cve_match:
                    continue

                cve_id = cve_match.group(0)

                # Only include recent CVEs (2020+)
                year_match = re.search(r"CVE-(\d{4})", cve_id)
                if year_match and int(year_match.group(1)) < 2020:
                    continue

                # Get CVE details
                cve_details = self._get_cve_details(cve_id)

                vulnerability = {
                    "cve_id": cve_id,
                    "definition_id": definition_id,
                    "title": title,
                    "description": description or "",
                    "affected_package": package_name,
                    "installed_version": version,
                    "cvss_score": cve_details.get("cvss_score", 0.0),
                    "severity": cve_details.get("severity", "unknown"),
                    "summary": cve_details.get("summary", ""),
                    "published_date": cve_details.get("published_date", ""),
                }

                vulnerabilities.append(vulnerability)

        except Exception as e:
            logger.warning(f"Error querying package {package_name}: {e}")

        return vulnerabilities

    def _is_really_about_package(
        self, title: str, description: str, package_name: str
    ) -> bool:
        """Conservative check if vulnerability is really about this package."""
        title_lower = title.lower()
        package_lower = package_name.lower()

        # Must have package name in title
        if package_lower not in title_lower:
            return False

        # Skip if it's clearly about something else
        false_indicators = [
            "linux",
            "kernel",
            "driver",
            "firmware",
            "bios",
            "windows",
            "android",
            "ios",
            "macos",
        ]

        for indicator in false_indicators:
            if indicator in title_lower and package_lower != indicator:
                return False

        return True

    def _get_cve_details(self, cve_id: str) -> Dict:
        """Get CVE details from CVE database."""
        try:
            with sqlite3.connect(self.cve_db_path) as conn:
                cursor = conn.cursor()

                cursor.execute(
                    """
                    SELECT 
                        n.cve_id,
                        n.published_date,
                        c3.base_score,
                        c3.base_severity,
                        d.value as description
                    FROM nvds n
                    LEFT JOIN nvd_cvss3 c3 ON n.id = c3.nvd_id
                    LEFT JOIN nvd_descriptions d ON n.id = d.nvd_id AND d.lang = 'en'
                    WHERE n.cve_id = ?
                    LIMIT 1
                """,
                    (cve_id,),
                )

                row = cursor.fetchone()
                if row:
                    return {
                        "published_date": row[1],
                        "cvss_score": row[2] if row[2] else 0.0,
                        "severity": row[3] if row[3] else "unknown",
                        "summary": row[4] if row[4] else "",
                    }
        except Exception as e:
            logger.debug(f"Could not get CVE details for {cve_id}: {e}")

        return {}

    def generate_report(self, vulnerabilities: List[Dict]) -> Dict:
        """Generate a focused vulnerability report."""
        if not vulnerabilities:
            return {
                "total_vulnerabilities": 0,
                "high_risk_packages": [],
                "vulnerabilities": [],
            }

        # Group by package
        by_package = {}
        for vuln in vulnerabilities:
            pkg = vuln["affected_package"]
            if pkg not in by_package:
                by_package[pkg] = []
            by_package[pkg].append(vuln)

        # Sort packages by risk (number of critical/high vulns)
        high_risk_packages = []
        for pkg, vulns in by_package.items():
            critical_count = sum(
                1 for v in vulns if v.get("severity", "").lower() == "critical"
            )
            high_count = sum(
                1 for v in vulns if v.get("severity", "").lower() == "high"
            )

            high_risk_packages.append(
                {
                    "package": pkg,
                    "total_vulns": len(vulns),
                    "critical": critical_count,
                    "high": high_count,
                    "risk_score": critical_count * 10 + high_count * 5 + len(vulns),
                }
            )

        high_risk_packages.sort(key=lambda x: x["risk_score"], reverse=True)

        return {
            "total_vulnerabilities": len(vulnerabilities),
            "packages_affected": len(by_package),
            "high_risk_packages": high_risk_packages,
            "vulnerabilities": vulnerabilities,
        }


def main():
    """CLI interface for conservative vulnerability checking."""
    import argparse

    parser = argparse.ArgumentParser(description="Conservative vulnerability checker")
    parser.add_argument(
        "--vuls-result", required=True, help="Path to Vuls scan result JSON"
    )
    parser.add_argument(
        "--oval-db", default="./db/oval.sqlite3", help="Path to OVAL database"
    )
    parser.add_argument(
        "--cve-db", default="./db/cve.sqlite3", help="Path to CVE database"
    )
    parser.add_argument("--output", help="Output JSON file")

    args = parser.parse_args()

    checker = SimpleVulnerabilityChecker(args.oval_db, args.cve_db)

    # Get installed packages
    packages = checker.get_installed_packages(args.vuls_result)
    print(f"Found {len(packages)} installed packages")

    # Check only high-risk packages
    vulnerabilities = checker.check_specific_packages(packages)

    # Generate report
    report = checker.generate_report(vulnerabilities)

    print(
        f"Found {report['total_vulnerabilities']} actual vulnerabilities in {report['packages_affected']} packages"
    )

    if args.output:
        with open(args.output, "w") as f:
            json.dump(report, f, indent=2)
        print(f"Report saved to {args.output}")
    else:
        print(json.dumps(report, indent=2))


if __name__ == "__main__":
    main()

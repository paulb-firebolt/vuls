"""Enhanced vulnerability checker service integrated for the web application."""

import sqlite3
import json
import os
import re
import logging
from typing import Dict, List, Set, Optional
from packaging import version
from pathlib import Path

logger = logging.getLogger(__name__)

# Import Debian Security Lookup
try:
    from .debian_security_lookup import DebianSecurityLookup
    DEBIAN_LOOKUP_AVAILABLE = True
except ImportError:
    logger.warning("Debian Security Lookup not available")
    DEBIAN_LOOKUP_AVAILABLE = False


class EnhancedVulnerabilityChecker:
    """Enhanced vulnerability checker that uses both OVAL and GOST databases."""

    def __init__(self, oval_db_path: str, gost_db_path: str, cve_db_path: str):
        self.oval_db_path = oval_db_path
        self.gost_db_path = gost_db_path
        self.cve_db_path = cve_db_path

        # Initialize Debian Security Lookup if available
        self.debian_lookup = None
        if DEBIAN_LOOKUP_AVAILABLE:
            try:
                self.debian_lookup = DebianSecurityLookup()
                logger.info("Debian Security Lookup initialized")
            except Exception as e:
                logger.warning(f"Failed to initialize Debian Security Lookup: {e}")

    def get_installed_packages(self, vuls_result_file: str) -> Dict[str, str]:
        """Extract installed packages from Vuls scan result."""
        try:
            if not os.path.exists(vuls_result_file):
                logger.error(f"Vuls result file not found: {vuls_result_file}")
                return {}

            logger.info(f"Reading Vuls result file: {vuls_result_file}")

            try:
                with open(vuls_result_file, "r") as f:
                    data = json.load(f)
            except PermissionError as pe:
                logger.error(f"Permission denied reading Vuls result file {vuls_result_file}: {pe}")
                return {}

            packages = {}

            # Handle both single server and multiple server formats
            if isinstance(data, dict):
                # Check if this is a direct server data or contains servers
                if "packages" in data:
                    # Direct server data
                    for pkg_name, pkg_info in data.get("packages", {}).items():
                        version = pkg_info.get("version", "")
                        packages[pkg_name] = version
                else:
                    # Multiple servers format - check each key for server data
                    for server_name, server_data in data.items():
                        if isinstance(server_data, dict) and "packages" in server_data:
                            for pkg_name, pkg_info in server_data.get("packages", {}).items():
                                version = pkg_info.get("version", "")
                                packages[pkg_name] = version

            logger.info(f"Extracted {len(packages)} packages from Vuls result")
            return packages

        except Exception as e:
            logger.error(f"Error reading Vuls result file {vuls_result_file}: {e}")
            return {}

    def identify_vulnerable_packages(self, all_packages: Dict[str, str]) -> Set[str]:
        """Dynamically identify packages that commonly have vulnerabilities."""

        # Always scan these critical packages (if installed)
        critical_packages = {
            "openssl",
            "openssh-server",
            "openssh-client",
            "sudo",
            "systemd",
            "libc6",
            "libc-bin",
            "glibc",
            "bash",
            "curl",
            "wget",
            "git",
        }

        # High-risk package patterns
        high_risk_patterns = [
            # Network/Web/Security
            (r".*ssh.*", "SSH-related"),
            (r".*ssl.*", "SSL/TLS libraries"),
            (r".*tls.*", "TLS libraries"),
            (r".*crypto.*", "Cryptographic libraries"),
            (r".*crypt.*", "Cryptographic libraries"),
            (r".*http.*", "HTTP libraries"),
            (r".*curl.*", "HTTP clients"),
            (r".*wget.*", "HTTP clients"),
            (r".*nginx.*", "Web servers"),
            (r".*apache.*", "Web servers"),
            # Languages/Runtimes
            (r".*java.*", "Java runtime"),
            (r".*jdk.*", "Java development kit"),
            (r".*jre.*", "Java runtime environment"),
            (r".*openjdk.*", "OpenJDK"),
            (r".*python.*", "Python runtime"),
            (r".*perl.*", "Perl runtime"),
            (r".*php.*", "PHP runtime"),
            (r".*ruby.*", "Ruby runtime"),
            (r".*node.*", "Node.js runtime"),
            # Databases
            (r".*sql.*", "Database systems"),
            (r".*maria.*", "MariaDB"),
            (r".*mysql.*", "MySQL"),
            (r".*postgres.*", "PostgreSQL"),
            (r".*redis.*", "Redis"),
            (r".*mongo.*", "MongoDB"),
            # Containers/Virtualization
            (r".*docker.*", "Docker containers"),
            (r".*container.*", "Container runtime"),
            (r".*containerd.*", "Container daemon"),
            (r".*runc.*", "Container runtime"),
            # System/Security
            (r".*sudo.*", "Privilege escalation"),
            (r".*systemd.*", "System daemon"),
            (r".*pam.*", "Authentication"),
            (r".*auth.*", "Authentication"),
            (r".*login.*", "Login systems"),
            (r".*shadow.*", "Password management"),
            # Parsers/Libraries (often vulnerable)
            (r".*xml.*", "XML parsers"),
            (r".*json.*", "JSON parsers"),
            (r".*yaml.*", "YAML parsers"),
            (r".*expat.*", "XML parser"),
            (r".*libxml.*", "XML library"),
            (r".*parser.*", "Parser libraries"),
            # Network libraries
            (r".*gnutls.*", "TLS library"),
            (r".*nettle.*", "Crypto library"),
            (r".*gcrypt.*", "Crypto library"),
            # Mail/DNS
            (r".*mail.*", "Mail systems"),
            (r".*smtp.*", "SMTP servers"),
            (r".*exim.*", "Exim mail server"),
            (r".*postfix.*", "Postfix mail server"),
            (r".*bind.*", "DNS server"),
            (r".*dns.*", "DNS systems"),
            # Archive/Compression
            (r".*zip.*", "Archive libraries"),
            (r".*tar.*", "Archive tools"),
            (r".*gzip.*", "Compression"),
            (r".*bzip.*", "Compression"),
            (r".*xz.*", "Compression"),
        ]

        vulnerable_packages = set(critical_packages)

        # Add packages matching high-risk patterns
        for pkg_name in all_packages.keys():
            for pattern, category in high_risk_patterns:
                if re.match(pattern, pkg_name, re.IGNORECASE):
                    vulnerable_packages.add(pkg_name)
                    logger.debug(f"Added {pkg_name} (matched {category})")
                    break

        # Filter to only packages that are actually installed
        installed_vulnerable = {
            pkg for pkg in vulnerable_packages if pkg in all_packages
        }

        logger.info(
            f"Identified {len(installed_vulnerable)} potentially vulnerable packages out of {len(all_packages)} total"
        )

        return installed_vulnerable

    def check_enhanced_vulnerabilities(self, all_packages: Dict[str, str]) -> List[Dict]:
        """Check vulnerabilities using both OVAL and GOST databases."""

        # Identify packages to scan
        packages_to_scan = self.identify_vulnerable_packages(all_packages)

        logger.info(f"Scanning {len(packages_to_scan)} potentially vulnerable packages using OVAL and GOST...")

        vulnerabilities = []

        # Check OVAL database
        oval_vulns = self._check_oval_vulnerabilities(packages_to_scan, all_packages)
        vulnerabilities.extend(oval_vulns)
        logger.info(f"Found {len(oval_vulns)} vulnerabilities from OVAL database")

        # Check GOST database
        gost_vulns = self._check_gost_vulnerabilities(packages_to_scan, all_packages)
        vulnerabilities.extend(gost_vulns)
        logger.info(f"Found {len(gost_vulns)} vulnerabilities from GOST database")

        # Deduplicate vulnerabilities (same CVE for same package)
        deduplicated = self._deduplicate_vulnerabilities(vulnerabilities)
        logger.info(f"After deduplication: {len(deduplicated)} unique vulnerabilities")

        return deduplicated

    def _check_oval_vulnerabilities(self, packages_to_scan: Set[str], all_packages: Dict[str, str]) -> List[Dict]:
        """Check vulnerabilities using OVAL database."""
        vulnerabilities = []

        try:
            with sqlite3.connect(self.oval_db_path) as conn:
                cursor = conn.cursor()

                for package_name in sorted(packages_to_scan):
                    if package_name in all_packages:
                        version = all_packages[package_name]
                        vulns = self._query_oval_package(cursor, package_name, version)
                        vulnerabilities.extend(vulns)

        except Exception as e:
            logger.error(f"Error checking OVAL vulnerabilities: {e}")

        return vulnerabilities

    def _check_gost_vulnerabilities(self, packages_to_scan: Set[str], all_packages: Dict[str, str]) -> List[Dict]:
        """Check vulnerabilities using GOST database."""
        vulnerabilities = []

        try:
            with sqlite3.connect(self.gost_db_path) as conn:
                cursor = conn.cursor()

                for package_name in sorted(packages_to_scan):
                    if package_name in all_packages:
                        version = all_packages[package_name]
                        vulns = self._query_gost_package(cursor, package_name, version)
                        vulnerabilities.extend(vulns)

        except Exception as e:
            logger.error(f"Error checking GOST vulnerabilities: {e}")

        return vulnerabilities

    def _query_oval_package(self, cursor, package_name: str, installed_version: str) -> List[Dict]:
        """Query OVAL database for package vulnerabilities."""
        vulnerabilities = []

        try:
            # Query to get CVE definitions and their fixed versions
            query = """
            SELECT DISTINCT d.definition_id, d.title, d.description, p.version as fixed_version
            FROM definitions d
            JOIN debians deb ON d.id = deb.definition_id
            JOIN packages p ON d.id = p.definition_id
            WHERE d.root_id = 3
            AND p.name = ?
            AND (d.title LIKE ? OR d.title LIKE ?)
            ORDER BY d.definition_id DESC
            """

            pattern1 = f"% {package_name} %"
            pattern2 = f"% {package_name}"

            cursor.execute(query, (package_name, pattern1, pattern2))

            for row in cursor.fetchall():
                definition_id, title, description, fixed_version = row

                # Additional validation
                if not self._is_really_about_package(title, description, package_name):
                    continue

                # Extract CVE ID
                cve_match = re.search(r"CVE-\d{4}-\d{4,}", title)
                if not cve_match:
                    continue

                cve_id = cve_match.group(0)

                # Only include recent CVEs (2018+) to reduce noise
                year_match = re.search(r"CVE-(\d{4})", cve_id)
                if year_match and int(year_match.group(1)) < 2018:
                    continue

                # VERSION COMPARISON: Check if installed version is vulnerable
                if not self._is_version_vulnerable(installed_version, fixed_version):
                    continue

                # Get CVE details
                cve_details = self._get_cve_details(cve_id)

                vulnerability = {
                    "cve_id": cve_id,
                    "source": "OVAL",
                    "definition_id": definition_id,
                    "title": title,
                    "description": description or "",
                    "affected_package": package_name,
                    "installed_version": installed_version,
                    "fixed_version": fixed_version,
                    "cvss_score": cve_details.get("cvss_score", 0.0),
                    "severity": cve_details.get("severity", "unknown"),
                    "summary": cve_details.get("summary", ""),
                    "published_date": cve_details.get("published_date", ""),
                }

                vulnerabilities.append(vulnerability)

        except Exception as e:
            logger.warning(f"Error querying OVAL for package {package_name}: {e}")

        return vulnerabilities

    def _query_gost_package(self, cursor, package_name: str, installed_version: str) -> List[Dict]:
        """Query GOST database for package vulnerabilities using correct Ubuntu schema."""
        vulnerabilities = []

        try:
            # Query using the correct GOST Ubuntu schema
            query = """
            SELECT DISTINCT
                c.candidate as cve_id,
                c.priority,
                c.description,
                c.public_date,
                p.package_name
            FROM ubuntu_cves c
            JOIN ubuntu_patches p ON c.id = p.ubuntu_cve_id
            WHERE p.package_name = ?
            AND c.candidate LIKE 'CVE-%'
            ORDER BY c.candidate DESC
            """

            cursor.execute(query, (package_name,))
            rows = cursor.fetchall()

            for row in rows:
                cve_id = row[0]
                priority = row[1] or "unknown"
                description = row[2] or ""
                public_date = row[3] or ""

                # Skip if no CVE ID
                if not cve_id or not cve_id.startswith('CVE-'):
                    continue

                # Only include recent CVEs (2018+) to reduce noise
                year_match = re.search(r"CVE-(\d{4})", cve_id)
                if year_match and int(year_match.group(1)) < 2018:
                    continue

                # Get CVE details from the CVE database
                cve_details = self._get_cve_details(cve_id)

                vulnerability = {
                    "cve_id": cve_id,
                    "source": "GOST",
                    "affected_package": package_name,
                    "installed_version": installed_version,
                    "fixed_version": "unknown",  # GOST doesn't provide this directly
                    "priority": priority,
                    "description": description,
                    "public_date": public_date,
                    "cvss_score": cve_details.get("cvss_score", 0.0),
                    "severity": cve_details.get("severity", priority),
                    "summary": cve_details.get("summary", description),
                    "published_date": cve_details.get("published_date", public_date),
                }

                vulnerabilities.append(vulnerability)

        except Exception as e:
            logger.warning(f"Error querying GOST for package {package_name}: {e}")

        return vulnerabilities

    def _enhance_vulnerability_with_cross_reference(self, vulnerability: Dict) -> Dict:
        """
        Enhance a vulnerability by cross-referencing with other databases.
        This is crucial for GOST vulnerabilities with unknown fixed versions.
        """
        cve_id = vulnerability.get("cve_id", "")
        package_name = vulnerability.get("affected_package", "")
        installed_version = vulnerability.get("installed_version", "")
        source = vulnerability.get("source", "")
        cvss_score = vulnerability.get("cvss_score", 0.0)
        severity = vulnerability.get("severity", "").upper()

        # Enhanced vulnerability with Debian Security Lookup for high-severity issues
        if (self.debian_lookup and
            (cvss_score >= 7.0 or severity in ['HIGH', 'CRITICAL']) and
            '+deb' in installed_version):

            # Ensure Debian data is up to date
            try:
                self.debian_lookup.download_and_cache_debian_data()
                debian_enhanced = self.debian_lookup.enhance_vulnerability_with_debian_data(vulnerability)
                if debian_enhanced != vulnerability:
                    logger.info(f"Enhanced {cve_id} with Debian Security Tracker data")
                    vulnerability = debian_enhanced
            except Exception as e:
                logger.warning(f"Error enhancing with Debian data: {e}")

        # If this is a GOST vulnerability with unknown fixed version, try to get more info
        if source == "GOST" and vulnerability.get("fixed_version") == "unknown":
            logger.debug(f"Enhancing GOST vulnerability {cve_id} for {package_name}")

            # Try to get version info from CVE/NVD description
            cve_details = self._get_cve_details(cve_id)
            if cve_details.get("summary"):
                version_info = self._extract_version_from_description(cve_details["summary"], cve_id)
                if version_info:
                    vulnerability.update(version_info)
                    vulnerability["enhanced_by"] = "cve_description_parsing"

            # Try to check OVAL database for the same CVE
            oval_info = self._check_oval_for_cve(cve_id, package_name)
            if oval_info:
                vulnerability.update(oval_info)
                vulnerability["enhanced_by"] = "oval_cross_reference"

        return vulnerability

    def _extract_version_from_description(self, description: str, cve_id: str) -> Optional[Dict]:
        """Extract version information from CVE description."""
        if not description:
            return None

        text = description.lower()

        # Pattern 1: "X.Y.Z and earlier" or "X.Y.Z or earlier"
        pattern1 = r"(\d+\.\d+(?:\.\d+)?)\s+(?:and|or)\s+earlier"
        match1 = re.search(pattern1, text)
        if match1:
            affected_version = match1.group(1)
            logger.info(f"Found 'and earlier' pattern for {cve_id}: affects <= {affected_version}")
            return {
                "extracted_affected_version": affected_version,
                "version_pattern": "and_earlier",
                "fixed_version": self._increment_version(affected_version)
            }

        # Pattern 2: "before X.Y.Z" or "prior to X.Y.Z"
        pattern2 = r"(?:before|prior\s+to)\s+(?:version\s+)?(\d+\.\d+(?:\.\d+)?)"
        match2 = re.search(pattern2, text)
        if match2:
            fixed_version = match2.group(1)
            logger.info(f"Found 'before/prior to' pattern for {cve_id}: fixed in {fixed_version}")
            return {
                "fixed_version": fixed_version,
                "version_pattern": "before",
                "extracted_fixed_version": fixed_version
            }

        # Pattern 3: "fixed in X.Y.Z"
        pattern3 = r"fixed\s+in\s+(?:version\s+)?(\d+\.\d+(?:\.\d+)?)"
        match3 = re.search(pattern3, text)
        if match3:
            fixed_version = match3.group(1)
            logger.info(f"Found 'fixed in' pattern for {cve_id}: fixed in {fixed_version}")
            return {
                "fixed_version": fixed_version,
                "version_pattern": "fixed_in",
                "extracted_fixed_version": fixed_version
            }

        return None

    def _increment_version(self, version_str: str) -> str:
        """Increment a version string to get the likely fixed version."""
        try:
            parts = version_str.split(".")
            if len(parts) >= 2:
                # Increment the patch version
                if len(parts) == 2:
                    return f"{parts[0]}.{parts[1]}.1"
                else:
                    patch = int(parts[2]) + 1
                    return f"{parts[0]}.{parts[1]}.{patch}"
        except:
            pass
        return "unknown"

    def _check_oval_for_cve(self, cve_id: str, package_name: str) -> Optional[Dict]:
        """Check if OVAL database has information for this CVE."""
        try:
            with sqlite3.connect(self.oval_db_path) as conn:
                cursor = conn.cursor()

                # First try with debians join (for Debian-specific data)
                query_debian = """
                SELECT DISTINCT d.definition_id, d.title, d.description, p.version as fixed_version
                FROM definitions d
                JOIN debians deb ON d.id = deb.definition_id
                JOIN packages p ON d.id = p.definition_id
                WHERE p.name = ?
                AND d.title LIKE ?
                LIMIT 1
                """

                cursor.execute(query_debian, (package_name, f"%{cve_id}%"))
                row = cursor.fetchone()

                if row:
                    definition_id, title, description, fixed_version = row
                    logger.info(f"Found OVAL Debian info for {cve_id}: fixed in {fixed_version}")
                    return {
                        "fixed_version": fixed_version,
                        "oval_definition_id": definition_id,
                        "oval_title": title,
                        "oval_source": "debian"
                    }

                # If no Debian data, try general OVAL data (Alpine, etc.)
                query_general = """
                SELECT DISTINCT d.definition_id, d.title, d.description, p.version as fixed_version
                FROM definitions d
                JOIN packages p ON d.id = p.definition_id
                WHERE p.name = ?
                AND d.title LIKE ?
                ORDER BY p.version DESC
                LIMIT 1
                """

                cursor.execute(query_general, (package_name, f"%{cve_id}%"))
                row = cursor.fetchone()

                if row:
                    definition_id, title, description, fixed_version = row
                    logger.info(f"Found OVAL general info for {cve_id}: fixed in {fixed_version}")
                    return {
                        "fixed_version": fixed_version,
                        "oval_definition_id": definition_id,
                        "oval_title": title,
                        "oval_source": "general"
                    }

        except Exception as e:
            logger.debug(f"Error checking OVAL for {cve_id}: {e}")

        return None

    def _is_duplicate_cve(self, cve_id: str) -> Optional[str]:
        """
        Check if a CVE is a duplicate of another CVE.
        Returns the primary CVE ID if this is a duplicate, None otherwise.
        """
        try:
            with sqlite3.connect(self.cve_db_path) as conn:
                cursor = conn.cursor()

                # Check CVE description for duplicate indicators
                cursor.execute(
                    """
                    SELECT d.value as description
                    FROM nvds n
                    LEFT JOIN nvd_descriptions d ON n.id = d.nvd_id AND d.lang = 'en'
                    WHERE n.cve_id = ?
                    LIMIT 1
                    """,
                    (cve_id,),
                )

                row = cursor.fetchone()
                if row and row[0]:
                    description = row[0].lower()

                    # Look for duplicate indicators in description
                    duplicate_patterns = [
                        r"duplicate of (cve-\d{4}-\d{4,})",
                        r"same as (cve-\d{4}-\d{4,})",
                        r"identical to (cve-\d{4}-\d{4,})",
                        r"see (cve-\d{4}-\d{4,})",
                    ]

                    for pattern in duplicate_patterns:
                        match = re.search(pattern, description)
                        if match:
                            primary_cve = match.group(1).upper()
                            logger.info(f"Found duplicate CVE: {cve_id} is duplicate of {primary_cve}")
                            return primary_cve

        except Exception as e:
            logger.debug(f"Error checking for duplicate CVE {cve_id}: {e}")

        # Check known duplicate mappings (only add when confirmed through external research)
        known_duplicates = {
            # Add confirmed duplicates here only when verified through:
            # - MITRE advisories
            # - Vendor security bulletins
            # - Manual research and confirmation
            # Example: "CVE-YYYY-XXXX": "CVE-YYYY-ZZZZ",
        }

        if cve_id in known_duplicates:
            primary_cve = known_duplicates[cve_id]
            logger.info(f"Known duplicate CVE: {cve_id} is duplicate of {primary_cve}")
            return primary_cve

        return None

    def _is_vulnerability_actually_applicable(self, vulnerability: Dict) -> bool:
        """
        Determine if a vulnerability is actually applicable to the installed version.
        This is especially important for GOST vulnerabilities with unknown fixed versions.
        """
        cve_id = vulnerability.get("cve_id", "")
        package_name = vulnerability.get("affected_package", "")
        installed_version = vulnerability.get("installed_version", "")
        fixed_version = vulnerability.get("fixed_version", "")
        source = vulnerability.get("source", "")

        # Check if this CVE is a duplicate of another CVE
        primary_cve = self._is_duplicate_cve(cve_id)
        if primary_cve:
            logger.info(f"Filtering duplicate CVE {cve_id} (duplicate of {primary_cve}) for {package_name}")
            return False

        # If we have a proper fixed version, use normal version comparison
        if fixed_version and fixed_version != "unknown":
            return self._is_version_vulnerable(installed_version, fixed_version)

        # For GOST vulnerabilities with unknown fixed versions, be more careful
        if source == "GOST" and fixed_version == "unknown":
            # Check if we extracted version info
            if vulnerability.get("extracted_affected_version"):
                affected_version = vulnerability["extracted_affected_version"]
                try:
                    # Extract upstream version from Debian package version
                    installed_upstream = self.parse_debian_version(installed_version)["upstream"]
                    installed_ver = version.parse(installed_upstream)
                    affected_ver = version.parse(affected_version)

                    # If installed version is significantly newer, likely not vulnerable
                    is_vulnerable = installed_ver <= affected_ver

                    logger.info(f"Version check for {cve_id}: {installed_upstream} vs {affected_version} = {'vulnerable' if is_vulnerable else 'safe'}")
                    return is_vulnerable

                except Exception as e:
                    logger.warning(f"Error comparing extracted versions for {cve_id}: {e}")

            # Check CVE year - if very old and package is recent, likely false positive
            year_match = re.search(r"CVE-(\d{4})", cve_id)
            if year_match:
                cve_year = int(year_match.group(1))
                if cve_year < 2020:  # CVE is old
                    # Check if package version suggests it's newer
                    if "+deb12" in installed_version or "+deb11" in installed_version:
                        logger.info(f"Old CVE {cve_id} ({cve_year}) likely not applicable to recent Debian package {installed_version}")
                        return False

        # Default to vulnerable if we can't determine (conservative approach)
        return True

    def _deduplicate_vulnerabilities(self, vulnerabilities: List[Dict]) -> List[Dict]:
        """Remove duplicate vulnerabilities and enhance with cross-references."""
        seen = set()
        deduplicated = []

        # First pass: enhance vulnerabilities with cross-references
        enhanced_vulnerabilities = []
        for vuln in vulnerabilities:
            enhanced_vuln = self._enhance_vulnerability_with_cross_reference(vuln)
            enhanced_vulnerabilities.append(enhanced_vuln)

        # Second pass: deduplicate and filter
        for vuln in enhanced_vulnerabilities:
            key = (vuln["cve_id"], vuln["affected_package"])

            # Check if vulnerability is actually applicable
            if not self._is_vulnerability_actually_applicable(vuln):
                logger.info(f"Filtered out likely false positive: {vuln['cve_id']} for {vuln['affected_package']}")
                continue

            if key not in seen:
                seen.add(key)
                deduplicated.append(vuln)
            else:
                # If we have a duplicate, prefer OVAL over GOST (more detailed)
                existing_idx = None
                for i, existing in enumerate(deduplicated):
                    if (existing["cve_id"], existing["affected_package"]) == key:
                        existing_idx = i
                        break

                if existing_idx is not None:
                    existing = deduplicated[existing_idx]
                    if vuln["source"] == "OVAL" and existing["source"] == "GOST":
                        # Replace GOST with OVAL
                        deduplicated[existing_idx] = vuln
                    elif vuln["source"] == "GOST" and existing["source"] == "OVAL":
                        # Keep OVAL, skip GOST
                        continue

        return deduplicated

    def parse_debian_version(self, version_str: str) -> Dict[str, str]:
        """
        Parse a Debian version string into its components.

        Format: [epoch:]upstream_version[-debian_revision][+build_info]
        Examples:
        - "7.88.1-10+deb12u12" -> {epoch: "", upstream: "7.88.1", debian: "10", build: "deb12u12"}
        - "1:7.88.1-10" -> {epoch: "1", upstream: "7.88.1", debian: "10", build: ""}
        - "7.88.1" -> {epoch: "", upstream: "7.88.1", debian: "", build: ""}
        """
        if not version_str:
            return {"epoch": "", "upstream": "0", "debian": "", "build": ""}

        # Handle epoch (1:version)
        epoch = ""
        remaining = version_str
        if ":" in version_str:
            epoch, remaining = version_str.split(":", 1)

        # Handle build info (+deb12u12)
        build = ""
        if "+" in remaining:
            remaining, build = remaining.split("+", 1)

        # Handle debian revision (-10)
        debian = ""
        if "-" in remaining:
            upstream, debian = remaining.rsplit("-", 1)
        else:
            upstream = remaining

        # Clean upstream version for pre-release handling
        upstream = self._clean_upstream_version(upstream)

        return {
            "epoch": epoch,
            "upstream": upstream,
            "debian": debian,
            "build": build
        }

    def _clean_upstream_version(self, version_str: str) -> str:
        """Clean upstream version for proper comparison."""
        if not version_str:
            return "0"

        # Handle pre-release versions with ~
        # 7.88.0~rc1 -> 7.88.0rc1
        cleaned = version_str.replace("~", "")

        # Handle git snapshots
        # 2.0.0~git20210101 -> 2.0.0.git20210101
        cleaned = re.sub(r"~git(\d+)", r".git\1", cleaned)

        # Remove any remaining invalid characters but keep rc, a, b for pre-releases
        cleaned = re.sub(r"[^0-9.rcab]", "", cleaned)

        # Ensure we have a valid version
        if not cleaned or cleaned == ".":
            return "0"

        return cleaned

    def compare_debian_versions(self, installed: str, fixed: str) -> int:
        """
        Compare two Debian version strings.
        Returns: -1 if installed < fixed (vulnerable)
                  0 if installed == fixed (equal)
                  1 if installed > fixed (safe)
        """
        try:
            inst_parts = self.parse_debian_version(installed)
            fixed_parts = self.parse_debian_version(fixed)

            # Compare epoch first
            inst_epoch = int(inst_parts["epoch"]) if inst_parts["epoch"] else 0
            fixed_epoch = int(fixed_parts["epoch"]) if fixed_parts["epoch"] else 0

            if inst_epoch != fixed_epoch:
                return -1 if inst_epoch < fixed_epoch else 1

            # Compare upstream versions
            try:
                inst_upstream = version.parse(inst_parts["upstream"])
                fixed_upstream = version.parse(fixed_parts["upstream"])

                if inst_upstream != fixed_upstream:
                    return -1 if inst_upstream < fixed_upstream else 1
            except Exception as e:
                logger.warning(f"Error comparing upstream versions: {e}")
                # Fall back to string comparison
                if inst_parts["upstream"] != fixed_parts["upstream"]:
                    return -1 if inst_parts["upstream"] < fixed_parts["upstream"] else 1

            # If upstream versions are equal, compare Debian revisions
            if inst_parts["debian"] and fixed_parts["debian"]:
                try:
                    inst_debian = int(inst_parts["debian"])
                    fixed_debian = int(fixed_parts["debian"])

                    if inst_debian != fixed_debian:
                        return -1 if inst_debian < fixed_debian else 1
                except ValueError:
                    # Non-numeric debian revisions, use string comparison
                    if inst_parts["debian"] != fixed_parts["debian"]:
                        return -1 if inst_parts["debian"] < fixed_parts["debian"] else 1

            # If Debian revisions are equal, compare build info (security updates)
            if inst_parts["build"] and fixed_parts["build"]:
                # Extract security update numbers (e.g., deb12u12 -> 12)
                inst_security = self._extract_security_update_number(inst_parts["build"])
                fixed_security = self._extract_security_update_number(fixed_parts["build"])

                if inst_security is not None and fixed_security is not None:
                    if inst_security != fixed_security:
                        return -1 if inst_security < fixed_security else 1

            return 0  # Versions are equal

        except Exception as e:
            logger.warning(f"Error comparing Debian versions {installed} vs {fixed}: {e}")
            # Default to vulnerable if we can't compare
            return -1

    def _extract_security_update_number(self, build_info: str) -> Optional[int]:
        """Extract security update number from build info (e.g., deb12u12 -> 12)."""
        match = re.search(r"deb\d+u(\d+)", build_info)
        if match:
            return int(match.group(1))
        return None

    def _is_version_vulnerable(self, installed_version: str, fixed_version: str) -> bool:
        """
        Improved version vulnerability check with proper Debian version handling.
        Returns True if installed version is vulnerable, False if safe.
        """
        try:
            comparison = self.compare_debian_versions(installed_version, fixed_version)

            # Log the comparison for debugging
            logger.debug(f"Version comparison: {installed_version} vs {fixed_version} = {comparison}")

            # If installed < fixed, it's vulnerable
            return comparison < 0

        except Exception as e:
            logger.warning(f"Error in improved version comparison {installed_version} vs {fixed_version}: {e}")
            # Default to vulnerable if we can't compare
            return True

    def _clean_debian_version(self, version_str: str) -> str:
        """
        Clean Debian version string for comparison.
        Examples:
        - "7.88.1-10+deb12u12" -> "7.88.1"
        - "7.61.0-1" -> "7.61.0"
        - "5.2.15-2+b8" -> "5.2.15"
        - "5.1~rc1-2" -> "5.1.0rc1"
        - "3.11.2-6+deb12u6" -> "3.11.2"
        - "3.11.0~b4-1" -> "3.11.0b4"
        """
        if not version_str:
            return "0"

        # Handle special Debian version characters
        # Replace ~ with . for pre-release versions (5.1~rc1 -> 5.1.rc1)
        cleaned = version_str.replace("~", ".")

        # Remove everything after the first dash (Debian revision)
        base_version = cleaned.split("-")[0]

        # Handle special cases for pre-release versions
        # Convert rc, alpha, beta to formats that packaging can understand
        base_version = re.sub(r"\.rc(\d+)", r"rc\1", base_version)  # .rc1 -> rc1
        base_version = re.sub(r"\.b(\d+)", r"b\1", base_version)    # .b4 -> b4
        base_version = re.sub(r"\.a(\d+)", r"a\1", base_version)    # .a1 -> a1

        # Remove any remaining non-version characters except rc, a, b for pre-releases
        cleaned = re.sub(r"[^0-9.rcab]", "", base_version)

        # Ensure we have a valid version string
        if not cleaned or cleaned == ".":
            return "0"

        return cleaned

    def _is_really_about_package(self, title: str, description: str, package_name: str) -> bool:
        """Conservative check if vulnerability is really about this package."""
        title_lower = title.lower()
        package_lower = package_name.lower()

        # Must have package name in title
        if package_lower not in title_lower:
            return False

        # Skip if it's clearly about something else
        false_indicators = [
            "linux",
            "kernel",
            "driver",
            "firmware",
            "bios",
            "windows",
            "android",
            "ios",
            "macos",
        ]

        for indicator in false_indicators:
            if indicator in title_lower and package_lower != indicator:
                return False

        return True

    def _get_cve_details(self, cve_id: str) -> Dict:
        """Get CVE details from CVE database."""
        try:
            with sqlite3.connect(self.cve_db_path) as conn:
                cursor = conn.cursor()

                cursor.execute(
                    """
                    SELECT
                        n.cve_id,
                        n.published_date,
                        c3.base_score,
                        c3.base_severity,
                        d.value as description
                    FROM nvds n
                    LEFT JOIN nvd_cvss3 c3 ON n.id = c3.nvd_id
                    LEFT JOIN nvd_descriptions d ON n.id = d.nvd_id AND d.lang = 'en'
                    WHERE n.cve_id = ?
                    LIMIT 1
                """,
                    (cve_id,),
                )

                row = cursor.fetchone()
                if row:
                    return {
                        "published_date": row[1],
                        "cvss_score": row[2] if row[2] else 0.0,
                        "severity": row[3] if row[3] else "unknown",
                        "summary": row[4] if row[4] else "",
                    }
        except Exception as e:
            logger.debug(f"Could not get CVE details for {cve_id}: {e}")

        return {}

    def generate_enhanced_report(self, vulnerabilities: List[Dict]) -> Dict:
        """Generate enhanced vulnerability report."""
        if not vulnerabilities:
            return {
                "total_vulnerabilities": 0,
                "packages_affected": 0,
                "vulnerability_breakdown": {},
                "source_breakdown": {},
                "high_risk_packages": [],
                "vulnerabilities": [],
            }

        # Group by package, severity, and source
        by_package = {}
        by_severity = {"CRITICAL": 0, "HIGH": 0, "MEDIUM": 0, "LOW": 0, "unknown": 0}
        by_source = {"OVAL": 0, "GOST": 0}

        for vuln in vulnerabilities:
            # By package
            pkg = vuln["affected_package"]
            if pkg not in by_package:
                by_package[pkg] = {
                    "total": 0,
                    "critical": 0,
                    "high": 0,
                    "medium": 0,
                    "low": 0,
                    "oval_count": 0,
                    "gost_count": 0,
                }

            by_package[pkg]["total"] += 1
            severity = vuln.get("severity", "unknown").upper()

            # Map severity to correct field names
            severity_mapping = {
                "CRITICAL": "critical",
                "HIGH": "high",
                "MEDIUM": "medium",
                "LOW": "low"
            }

            if severity in severity_mapping:
                by_package[pkg][severity_mapping[severity]] += 1

            # By severity
            if severity in by_severity:
                by_severity[severity] += 1
            else:
                by_severity["unknown"] += 1

            # By source
            source = vuln.get("source", "unknown")
            if source in by_source:
                by_source[source] += 1
                by_package[pkg][f"{source.lower()}_count"] += 1

        # Calculate risk scores
        high_risk_packages = []
        for pkg, counts in by_package.items():
            risk_score = (
                counts["critical"] * 20
                + counts["high"] * 10
                + counts["medium"] * 5
                + counts["low"] * 1
            )

            high_risk_packages.append(
                {
                    "package": pkg,
                    "total_vulns": counts["total"],
                    "critical": counts["critical"],
                    "high": counts["high"],
                    "medium": counts["medium"],
                    "low": counts["low"],
                    "oval_count": counts["oval_count"],
                    "gost_count": counts["gost_count"],
                    "risk_score": risk_score,
                }
            )

        high_risk_packages.sort(key=lambda x: x["risk_score"], reverse=True)

        return {
            "total_vulnerabilities": len(vulnerabilities),
            "packages_affected": len(by_package),
            "vulnerability_breakdown": by_severity,
            "source_breakdown": by_source,
            "high_risk_packages": high_risk_packages,
            "vulnerabilities": vulnerabilities,
        }
